


ARM Macro Assembler    Page 1 Lab Exercise Seven Circular FIFO Queue operations


    1 00000000                 TTL              Lab Exercise Seven Circular FIFO Queue operations
    2 00000000         ;****************************************************************
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;(What does the program do?)
    5 00000000         ;Name:  <Atticus Russell>
    6 00000000         ;Date:  <3/11/2021> <3/31/2021>
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  <Section 01L1, Thursday, 2:00-3:55>
    9 00000000         ;---------------------------------------------------------------
   10 00000000         ;Keil Template for KL05
   11 00000000         ;R. W. Melton
   12 00000000         ;September 13, 2020
   13 00000000         ;****************************************************************
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;****************************************************************
   18 00000000         ;Include files
   19 00000000                 GET              MKL05Z4.s   ;Included by start.s
   21 00000000         ;****************************************************************
   22 00000000         ;EQUates
   23 00000000         ; Queue management record field offsets
   24 00000000 00000000 
                       IN_PTR  EQU              0
   25 00000000 00000004 
                       OUT_PTR EQU              4
   26 00000000 00000008 
                       BUF_STRT
                               EQU              8
   27 00000000 0000000C 
                       BUF_PAST
                               EQU              12
   28 00000000 00000010 
                       BUF_SIZE
                               EQU              16
   29 00000000 00000011 
                       NUM_ENQD
                               EQU              17
   30 00000000         ; Queue structure sizes
   31 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4           ;Queue contents
   32 00000000 00000012 



ARM Macro Assembler    Page 2 Lab Exercise Seven Circular FIFO Queue operations


                       Q_REC_SZ
                               EQU              18          ;Queue management record
   33 00000000         ; Number of bytes in prompts
   34 00000000 00000020 
                       PROMPT_QUEUE_LEN
                               EQU              32          ;
   35 00000000 00000007 
                       FAILURE_STR_LEN
                               EQU              7           ;
   36 00000000 00000014 
                       ENQUEUE_STR_LEN
                               EQU              20          ;
   37 00000000 00000007 
                       SUCCESS_STR_LEN
                               EQU              7           ;
   38 00000000 00000006 
                       STATUS_STR_LEN
                               EQU              6           ;
   39 00000000 00000004 
                       IN_STR_LEN
                               EQU              4           ;
   40 00000000 00000008 
                       OUT_STR_LEN
                               EQU              8           ;
   41 00000000 00000003 
                       NUM_STR_LEN
                               EQU              3           ;
   42 00000000 00000038 
                       HELP_STR_LEN
                               EQU              56          ;
   43 00000000         ;For text output and related subroutines
   44 00000000 0000000D 
                       CR      EQU              0x0D        ;moves cursor beginning line
   45 00000000 0000000A 
                       LF      EQU              0x0A        ;adds new line
   46 00000000 00000000 
                       NULL    EQU              0x00        ;the null character
   47 00000000         ;---------------------------------------------------------------
   48 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   49 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   50 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   51 00000000         ;---------------------------------------------------------------



ARM Macro Assembler    Page 3 Lab Exercise Seven Circular FIFO Queue operations


   52 00000000         ;Port B
   54 00000000 01000200 
                       PORT_PCR_SET_PTB2_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   56 00000000 01000200 
                       PORT_PCR_SET_PTB1_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   57 00000000         ;---------------------------------------------------------------
   58 00000000         ;SIM_SCGC4
   59 00000000         ;1->10:UART0 clock gate control (enabled)
   60 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   61 00000000         ;---------------------------------------------------------------
   62 00000000         ;SIM_SCGC5
   63 00000000         ;1->10:Port B clock gate control (enabled)
   64 00000000         ;Use provided SIM_SCGC5_PORTB_MASK
   65 00000000         ;---------------------------------------------------------------
   66 00000000         ;SIM_SOPT2
   67 00000000         ;01=27-26:UART0SRC=UART0 clock source select (MCGFLLCLK)
   68 00000000         ;---------------------------------------------------------------
   70 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGFLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   71 00000000         ;---------------------------------------------------------------
   72 00000000         ;SIM_SOPT5
   73 00000000         ; 0->   16:UART0 open drain enable (disabled)
   74 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   75 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   79 00000000 00010005 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   80 00000000         ;---------------------------------------------------------------
   81 00000000         ;UART0_BDH
   82 00000000         ;    0->  7:LIN break detect IE (disabled)
   83 00000000         ;    0->  6:RxD input active edge IE (disabled)
   84 00000000         ;    0->  5:Stop bit number select (1)
   85 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   86 00000000         ;UART0CLK is MCGFLLCLK
   87 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   88 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138



ARM Macro Assembler    Page 4 Lab Exercise Seven Circular FIFO Queue operations


   89 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   90 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   91 00000000         ;---------------------------------------------------------------
   92 00000000         ;UART0_BDL
   93 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   94 00000000         ;UART0CLK is MCGFLLCLK
   95 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   96 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   97 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   98 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   99 00000000         ;---------------------------------------------------------------
  100 00000000         ;UART0_C1
  101 00000000         ;0-->7:LOOPS=loops select (normal)
  102 00000000         ;0-->6:DOZEEN=doze enable (disabled)
  103 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
  104 00000000         ;0-->4:M=9- or 8-bit mode select 
  105 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
  106 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
  107 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
  108 00000000         ;0-->1:PE=parity enable (disabled)
  109 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
  110 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
  111 00000000         ;---------------------------------------------------------------
  112 00000000         ;UART0_C2
  113 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
  114 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
  115 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
  116 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  117 00000000         ;1-->3:TE=transmitter enable (enabled)
  118 00000000         ;1-->2:RE=receiver enable (enabled)
  119 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  120 00000000         ;0-->0:SBK=send break (disabled, normal)
  121 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  122 00000000         ;---------------------------------------------------------------



ARM Macro Assembler    Page 5 Lab Exercise Seven Circular FIFO Queue operations


  123 00000000         ;UART0_C3
  124 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  125 00000000         ;           10th data bit for transmitter (not used M10=0)
  126 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  127 00000000         ;           10th data bit for receiver (not used M10=0)
  128 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  129 00000000         ;            (no effect LOOPS=0)
  130 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  131 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  132 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  133 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  134 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  135 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  136 00000000         ;---------------------------------------------------------------
  137 00000000         ;UART0_C4
  138 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  139 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  140 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  141 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  142 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  143 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  144 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  145 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  146 00000000         ;---------------------------------------------------------------
  147 00000000         ;UART0_C5
  148 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  149 00000000         ;  0-->  6:Reserved; read-only; always 0
  150 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  151 00000000         ;000-->4-2:Reserved; read-only; always 0
  152 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  153 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  154 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  155 00000000         ;---------------------------------------------------------------
  156 00000000         ;UART0_S1



ARM Macro Assembler    Page 6 Lab Exercise Seven Circular FIFO Queue operations


  157 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  158 00000000         ;0-->6:TC=transmission complete flag; read-only
  159 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  160 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  161 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  162 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  163 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  164 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  169 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              (UART0_S1_IDLE_MASK :OR:                              UART0_S1_OR_MASK 
:OR:                              UART0_S1_NF_MASK :OR:                              UART0_S1_FE_MASK :OR:           
                   UART0_S1_PF_MASK)
  170 00000000         ;---------------------------------------------------------------
  171 00000000         ;UART0_S2
  172 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  173 00000000         ;             write 1 to clear
  174 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  175 00000000         ;              write 1 to clear
  176 00000000         ;0-->5:(reserved); read-only; always 0
  177 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  178 00000000         ;0-->3:RWUID=receive wake-up idle detect
  179 00000000         ;0-->2:BRK13=break character generation length (10)
  180 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  181 00000000         ;0-->0:RAF=receiver active flag; read-only
  183 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              (UART0_S2_LBKDIF_MASK :OR: UART0_S2_RXEDGIF_MASK)
  184 00000000         ;---------------------------------------------------------------
  185 00000000         ;****************************************************************
  186 00000000         ;Program
  187 00000000         ;Linker requires Reset_Handler
  188 00000000                 AREA             MyCode,CODE,READONLY
  189 00000000                 ENTRY
  190 00000000                 EXPORT           Reset_Handler
  191 00000000                 IMPORT           Startup
  192 00000000         Reset_Handler
                               PROC             {}
  193 00000000         main
  194 00000000         ;---------------------------------------------------------------
  195 00000000         ;Mask interrupts
  196 00000000 B672            CPSID            I



ARM Macro Assembler    Page 7 Lab Exercise Seven Circular FIFO Queue operations


  197 00000002         ;KL05 system startup with 48-MHz system clock
  198 00000002 F7FF FFFE       BL               Startup
  199 00000006         ;---------------------------------------------------------------
  200 00000006         ;>>>>> begin main program code <<<<<
  201 00000006 F7FF FFFE       BL               Init_UART0_Polling
  202 0000000A 48E4            LDR              R0,=QBuffer
  203 0000000C 49E4            LDR              R1,=QRecord
  204 0000000E 2204            MOVS             R2,#4
  205 00000010 F7FF FFFE       BL               InitQueue   ;initialize the queue
  206 00000014         loopHereInput
  207 00000014 F7FF FFFE       BL               CRLF        ;output CR and LF to terminal
  208 00000018         ;output propmpt to terminal
  209 00000018 48E2            LDR              R0,=PROMPT_QUEUE
  210 0000001A 2120            MOVS             R1,#PROMPT_QUEUE_LEN
  211 0000001C F7FF FFFE       BL               PutStringSB
  212 00000020 F7FF FFFE       BL               GetChar     ;get the typed char
  213 00000024         ;checking if char is lowercase
  214 00000024 287A            CMP              R0,#'z'     ;check if ASCII is greater than 'z;
  215 00000026 D803            BHI              notLowerCase
  216 00000028 2861            CMP              R0,#'a'
  217 0000002A D301            BLO              notLowerCase ;check if ASCII is less than 'a'
  218 0000002C         ;Converting lowercase to uppercase
  219 0000002C 0007            MOVS             R7,R0       ;save a copy to r7
  220 0000002E 3820            SUBS             R0,R0,#32   ;otherwise make uppercase subtract 32
  221 00000030         notLowerCase
  222 00000030 0007            MOVS             R7,R0       ;save a copy to r7
  223 00000032 2844            CMP              R0,#'D'
  224 00000034 D008            BEQ              DInstruction
  225 00000036 2845            CMP              R0,#'E'
  226 00000038 D022            BEQ              EInstruction
  227 0000003A 2848            CMP              R0,#'H'
  228 0000003C D046            BEQ              HInstruction
  229 0000003E 2850            CMP              R0,#'P'
  230 00000040 D050            BEQ              PInstruction
  231 00000042 2853            CMP              R0,#'S'
  232 00000044 D06B            BEQ              SInstruction
  233 00000046         ;otherwise repeat regular 
  234 00000046 E7E5            B                loopHereInput
  235 00000048         ;Special instructions
  236 00000048         DInstruction
  237 00000048 0038            MOVS             R0,R7       ;restore saved typed char
  238 0000004A F7FF FFFE       BL               PutChar     ;output typed char to terminal



ARM Macro Assembler    Page 8 Lab Exercise Seven Circular FIFO Queue operations


  239 0000004E F7FF FFFE       BL               CRLF        ;output CR and LF
  240 00000052 49D3            LDR              R1,=QRecord
  241 00000054 F7FF FFFE       BL               Dequeue
  242 00000058 D209            BCS              dequeueEmpty ;if carry set then no char
  243 0000005A F7FF FFFE       BL               PutChar     ;output char from queue to terminal
  244 0000005E 203A            MOVS             R0,#':'     ;move ascii colon to r0
  245 00000060 F7FF FFFE       BL               PutChar     ;output colon
  246 00000064 48D0            LDR              R0,=SPACES8
  247 00000066 2108            MOVS             R1,#8
  248 00000068 F7FF FFFE       BL               PutStringSB ;print 8 spaces ("        ") to terminal
  249 0000006C E067            B                step9       ;branch to step 9
  250 0000006E         dequeueEmpty
  251 0000006E 48CF            LDR              R0,=FAILURE_STR
  252 00000070 2107            MOVS             R1,#FAILURE_STR_LEN
  253 00000072 F7FF FFFE       BL               PutStringSB ;print "Failure:" to terminal
  254 00000076 48CE            LDR              R0,=SPACES2
  255 00000078 2102            MOVS             R1,#2
  256 0000007A F7FF FFFE       BL               PutStringSB ;print 2 spaces ("  ") to terminal
  257 0000007E E05E            B                step9       ;branch to step9
  258 00000080         EInstruction
  259 00000080 0038            MOVS             R0,R7       ;restore saved typed char
  260 00000082 F7FF FFFE       BL               PutChar     ;output typed char to terminal
  261 00000086 F7FF FFFE       BL               CRLF        ;output CR and LF
  262 0000008A 48CA            LDR              R0,=ENQUEUE_STR
  263 0000008C 2114            MOVS             R1,#ENQUEUE_STR_LEN
  264 0000008E F7FF FFFE       BL               PutStringSB ;print enqueue prompt to terminal
  265 00000092         ;get and show typed char - followed by CRLF
  266 00000092 F7FF FFFE       BL               GetChar
  267 00000096 0002            MOVS             R2,R0       ;move char to R2 for safekeeping 
  268 00000098 F7FF FFFE       BL               PutChar
  269 0000009C F7FF FFFE       BL               CRLF
  270 000000A0 49BF            LDR              R1,=QRecord ;R1 <- addr QRecord
  271 000000A2 F7FF FFFE       BL               Enqueue     ;enque that char
  272 000000A6 D208            BCS              enqueueFail ;if c set then enqueue failed 
  273 000000A8 48C3            LDR              R0,=SUCCESS_STR
  274 000000AA 2107            MOVS             R1,#SUCCESS_STR_LEN
  275 000000AC F7FF FFFE       BL               PutStringSB ;print "Success:" to terminal
  276 000000B0 48BF            LDR              R0,=SPACES2
  277 000000B2 2102            MOVS             R1,#2
  278 000000B4 F7FF FFFE       BL               PutStringSB ;print 2 spaces ("  ") to terminal
  279 000000B8 E041            B                step9
  280 000000BA         enqueueFail



ARM Macro Assembler    Page 9 Lab Exercise Seven Circular FIFO Queue operations


  281 000000BA 48BC            LDR              R0,=FAILURE_STR
  282 000000BC 2107            MOVS             R1,#FAILURE_STR_LEN
  283 000000BE F7FF FFFE       BL               PutStringSB ;print "Failure:" to terminal
  284 000000C2 48BB            LDR              R0,=SPACES2
  285 000000C4 2102            MOVS             R1,#2
  286 000000C6 F7FF FFFE       BL               PutStringSB ;print 2 spaces ("  ") to terminal
  287 000000CA E038            B                step9
  288 000000CC         HInstruction
  289 000000CC 0038            MOVS             R0,R7       ;restore saved typed char
  290 000000CE F7FF FFFE       BL               PutChar     ;output typed char to terminal
  291 000000D2 F7FF FFFE       BL               CRLF        ;output CR and LF
  292 000000D6 48B9            LDR              R0,=HELP_STR
  293 000000D8 2138            MOVS             R1,#HELP_STR_LEN
  294 000000DA F7FF FFFE       BL               PutStringSB ;print helpStr to terminal
  295 000000DE F7FF FFFE       BL               CRLF        ;output CR and LF
  296 000000E2 E797            B                loopHereInput ;back to top
  297 000000E4         PInstruction
  298 000000E4 0038            MOVS             R0,R7       ;restore saved typed char
  299 000000E6 F7FF FFFE       BL               PutChar     ;output typed char to terminal
  300 000000EA F7FF FFFE       BL               CRLF        ;output CR and LF
  301 000000EE 203E            MOVS             R0,#'>'     ;load '>'
  302 000000F0 F7FF FFFE       BL               PutChar     ;print '>'
  303 000000F4         ;print all actively queued characters in queue
  304 000000F4 4AAA            LDR              R2,=QRecord ;R2 <- addr QRecord
  305 000000F6 6854            LDR              R4,[R2,#OUT_PTR] ;R4 <- addr OUT_PTR
  306 000000F8 7C55            LDRB             R5,[R2,#NUM_ENQD] ;R5 <- NUM_ENQD
  307 000000FA 68D6            LDR              R6,[R2,#BUF_PAST] ;R6 <- addr BUF_PAST
  308 000000FC 6897            LDR              R7,[R2,#BUF_STRT] ;R7 <- addr BUF_STRT
  309 000000FE         printyLoop
  310 000000FE 2100            MOVS             R1,#0
  311 00000100 428D            CMP              R5,R1       ;if number enqueued (or our equiv)
  312 00000102 D008            BEQ              noMorePrinty ;is zero, no more left
  313 00000104         ;if not zero then get + print the next
  314 00000104 7820            LDRB             R0,[R4,#0]  ;R0 <- contents addr r4 (at OUT_PTR)
  315 00000106 F7FF FFFE       BL               PutChar     ;Print Ascii in R0 to terminal   
  316 0000010A 1E6D            SUBS             R5,R5,#1    ;decrement NUM_ENQD equiv by 1
  317 0000010C 1C64            ADDS             R4,R4,#1    ;increment OUT_PTR addr equiv by 1
  318 0000010E 42B4            CMP              R4,R6
  319 00000110 D1F5            BNE              printyLoop  ;if OUT_PTR =! BUF_PAST go again
  320 00000112 6894            LDR              R4,[R2,#BUF_STRT] ;if is past buf go to buf strt
  321 00000114 E7F3            B                printyLoop  ;try print again
  322 00000116         noMorePrinty



ARM Macro Assembler    Page 10 Lab Exercise Seven Circular FIFO Queue operations


  323 00000116 203C            MOVS             R0,#'<'     ;load '<'
  324 00000118 F7FF FFFE       BL               PutChar     ;print '<'
  325 0000011C E77A            B                loopHereInput ;go get new input
  326 0000011E         SInstruction
  327 0000011E 0038            MOVS             R0,R7       ;restore saved typed char
  328 00000120 F7FF FFFE       BL               PutChar     ;output typed char to terminal
  329 00000124 F7FF FFFE       BL               CRLF        ;output CR and LF
  330 00000128 2020            MOVS             R0,#' '     ;load ' '
  331 0000012A F7FF FFFE       BL               PutChar     ;print a single space to terminal
  332 0000012E 48A4            LDR              R0,=STATUS_STR
  333 00000130 2106            MOVS             R1,#STATUS_STR_LEN
  334 00000132 F7FF FFFE       BL               PutStringSB ;print "Status:" to terminal
  335 00000136 489E            LDR              R0,=SPACES2
  336 00000138 2102            MOVS             R1,#2
  337 0000013A F7FF FFFE       BL               PutStringSB ;print 2 spaces ("  ") to terminal
  338 0000013E         ;just continue to step 9
  339 0000013E         step9
  340 0000013E 48A1            LDR              R0,=IN_STR
  341 00000140 2104            MOVS             R1,#IN_STR_LEN
  342 00000142 F7FF FFFE       BL               PutStringSB ;print "In=0x" to terminal
  343 00000146         
  344 00000146 4A96            LDR              R2,=QRecord ;R2 <- addr QRecord
  345 00000148 6813            LDR              R3,[R2,#IN_PTR] ;R3 <- addr IN_PTR
  346 0000014A 6854            LDR              R4,[R2,#OUT_PTR] ;R4 <- addr OUT_PTR
  347 0000014C 7C55            LDRB             R5,[R2,#NUM_ENQD] ;R5 <- addr NUM_ENQD
  348 0000014E         ;LDRB R5,[R5,#0]  ;R5 <- NUM_ENQD
  349 0000014E         
  350 0000014E 0018            MOVS             R0,R3       ;copy IN_PTR to R0
  351 00000150 F7FF FFFE       BL               PutNumHex   ;Print  IN_PTR to terminal
  352 00000154         
  353 00000154 4896            LDR              R0,=SPACES2
  354 00000156 2102            MOVS             R1,#2
  355 00000158 F7FF FFFE       BL               PutStringSB ;print 2 spaces ("  ") to terminal
  356 0000015C         
  357 0000015C 489A            LDR              R0,=OUT_STR
  358 0000015E 2108            MOVS             R1,#OUT_STR_LEN
  359 00000160 F7FF FFFE       BL               PutStringSB ;print "Out=0x" to terminal
  360 00000164         
  361 00000164 0020            MOVS             R0,R4       ;move OUT_PTR to R0
  362 00000166 F7FF FFFE       BL               PutNumHex   ;Print OUT_PTR to terminal
  363 0000016A         
  364 0000016A 4891            LDR              R0,=SPACES2



ARM Macro Assembler    Page 11 Lab Exercise Seven Circular FIFO Queue operations


  365 0000016C 2102            MOVS             R1,#2
  366 0000016E F7FF FFFE       BL               PutStringSB ;print 2 spaces ("  ") to terminal
  367 00000172         
  368 00000172 4896            LDR              R0,=NUM_STR
  369 00000174 2103            MOVS             R1,#NUM_STR_LEN
  370 00000176 F7FF FFFE       BL               PutStringSB ;print "Num=" to terminal
  371 0000017A         
  372 0000017A 0028            MOVS             R0,R5       ;move NUM_ENQD to R0
  373 0000017C F7FF FFFE       BL               PutNumUB    ;Print NUM_ENQD to terminal
  374 00000180         
  375 00000180 E748            B                loopHereInput ;go to top of looooooop
  376 00000182         
  377 00000182         ;>>>>>   end main program code <<<<<
  378 00000182         ;Stay here
  379 00000182 E7FE            B                .
  380 00000184                 ENDP
  381 00000184         ;>>>>> begin subroutine code <<<<<
  382 00000184         
  383 00000184         CRLF    PROC             {R0-R14}
  384 00000184         ;****************************************************************
  385 00000184         ;Description:
  386 00000184         ; This subroutine outputs a carriage return and a line-feed to
  387 00000184         ; the terminal screen.
  388 00000184         ;Input Parameter:
  389 00000184         ; none
  390 00000184         ;Output Parameter:
  391 00000184         ; none
  392 00000184         ;modified registers:
  393 00000184         ; none
  394 00000184         ;subroutines utilized:
  395 00000184         ; PutChar
  396 00000184         ;****************************************************************
  397 00000184 B501            PUSH             {LR,R0}
  398 00000186 200D            MOVS             R0,#CR      ;load carriage return
  399 00000188 F7FF FFFE       BL               PutChar     ;print carriage return
  400 0000018C 200A            MOVS             R0,#LF      ;load line feed
  401 0000018E F7FF FFFE       BL               PutChar     ;print line feed
  402 00000192 BD01            POP              {PC,R0}
  403 00000194 4770            BX               LR
  404 00000196                 ENDP
  405 00000196         
  406 00000196         JustClearC



ARM Macro Assembler    Page 12 Lab Exercise Seven Circular FIFO Queue operations


                               PROC             {R0-R14}
  407 00000196         ;****************************************************************
  408 00000196         ;Description:
  409 00000196         ; A subroutine with the sole purpose of setting the PSR 
  410 00000196         ; bit "C" to 0
  411 00000196         ;Input Parameter:
  412 00000196         ; none
  413 00000196         ;Output Parameter:
  414 00000196         ; C: APSR bit set to 0, other PSR bits unchanged
  415 00000196         ;modified registers:
  416 00000196         ; no registers other than PSR bit C have changed values
  417 00000196         ; after return
  418 00000196         ;****************************************************************
  419 00000196 B503            PUSH             {LR,R0-R1}
  420 00000198 F3EF 8000       MRS              R0,APSR
  421 0000019C 2120            MOVS             R1,#0x20
  422 0000019E 0609            LSLS             R1,R1,#24
  423 000001A0 4388            BICS             R0,R0,R1
  424 000001A2 F380 8800       MSR              APSR,R0
  425 000001A6 BD03            POP              {PC,R0-R1}
  426 000001A8 4770            BX               LR
  427 000001AA                 ENDP
  428 000001AA         
  429 000001AA         JustSetC
                               PROC             {R0-R14}
  430 000001AA         ;****************************************************************
  431 000001AA         ;Description:
  432 000001AA         ; A subroutine with the sole purpose of setting the APSR 
  433 000001AA         ; bit "C" to 1
  434 000001AA         ;Input Parameter:
  435 000001AA         ; none
  436 000001AA         ;Output Parameter:
  437 000001AA         ; C: APSR bit set to 1, other PSR bits unchanged
  438 000001AA         ;modified registers:
  439 000001AA         ; no registers other than PSR bit C have changed values
  440 000001AA         ; after return
  441 000001AA         ;****************************************************************
  442 000001AA B503            PUSH             {LR,R0-R1}
  443 000001AC F3EF 8000       MRS              R0,APSR
  444 000001B0 2120            MOVS             R1,#0x20
  445 000001B2 0609            LSLS             R1,R1,#24
  446 000001B4 4308            ORRS             R0,R0,R1



ARM Macro Assembler    Page 13 Lab Exercise Seven Circular FIFO Queue operations


  447 000001B6 F380 8800       MSR              APSR,R0
  448 000001BA BD03            POP              {PC,R0-R1}
  449 000001BC 4770            BX               LR
  450 000001BE                 ENDP
  451 000001BE         
  452 000001BE         Dequeue PROC             {R2-R14}
  453 000001BE         ;****************************************************************
  454 000001BE         ;Description:
  455 000001BE         ; Attempts to get a character from the queue whose record structure’s
  456 000001BE         ; address is in R1: if the queue is not empty, dequeues a single character
  457 000001BE         ; from the queue to R0, and returns with the PSR C bit cleared, (i.e., 0),
  458 000001BE         ; to report dequeue success, otherwise, returns with the PSR C bit set, 
  459 000001BE         ; (i.e., 1), to report dequeue failure.
  460 000001BE         ;Input Parameter: 
  461 000001BE         ; R1: queue record structure (unsigned word address)
  462 000001BE         ;Output Parameter/: 
  463 000001BE         ; R0: character dequeued (unsigned byte ASCII code)
  464 000001BE         ; R1: queue record structure (unsigned word address)
  465 000001BE         ; C: dequeue operation status: 0 success; 1 failure (PSR bit flag)
  466 000001BE         ;modified registers:
  467 000001BE         ; no registers other than PSR (and any output parameters) have changed values
  468 000001BE         ; after return
  469 000001BE         ;subroutines utilized:
  470 000001BE         ; JustClearC
  471 000001BE         ; JustSetC
  472 000001BE         ;****************************************************************
  473 000001BE B51C            PUSH             {LR,R2-R4}
  474 000001C0         ;first check if the queue is empty - if so indicate failure + end
  475 000001C0 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;R2 <- number of items in queue
  476 000001C2 2300            MOVS             R3,#0       ;R3 <- 0
  477 000001C4 429A            CMP              R2,R3
  478 000001C6 D00F            BEQ              queueEmpty  ;if num_enqued==0,end and fail
  479 000001C8         ;otherwise dequeue into r0, update record, and indicate success
  480 000001C8 684C            LDR              R4,[R1,#OUT_PTR] ;load OUT_PTR addr into R4
  481 000001CA 7820            LDRB             R0,[R4,#0]  ;load byte value stored in addr in R4
  482 000001CC         ;update records and such
  483 000001CC 1E52            SUBS             R2,R2,#1    ;r2 <- r2-1
  484 000001CE 744A            STRB             R2,[R1,#NUM_ENQD] ;store decremented number s
  485 000001D0         ;increment OUT_PTR (loop it to BUF_STRT if it hits BUF_PAST)
  486 000001D0 684A            LDR              R2,[R1,#OUT_PTR]
  487 000001D2 1C52            ADDS             R2,R2,#1    ;increment OUT_PTR
  488 000001D4 68CB            LDR              R3,[R1,#BUF_PAST]



ARM Macro Assembler    Page 14 Lab Exercise Seven Circular FIFO Queue operations


  489 000001D6 429A            CMP              R2,R3
  490 000001D8 DA01            BGE              passedBuffer ;branch if hit buf_past
  491 000001DA 604A            STR              R2,[R1,#OUT_PTR] ;if no branch, store incremented out ptr
  492 000001DC E001            B                successDequeue ;branch to clear c and end
  493 000001DE         passedBuffer
  494 000001DE 688B            LDR              R3,[R1,#BUF_STRT]
  495 000001E0 604B            STR              R3,[R1,#OUT_PTR] ;store new out pointer as start of buf 
  496 000001E2         successDequeue                       ;clear c and end subroutine
  497 000001E2 F7FF FFFE       BL               JustClearC
  498 000001E6 E001            B                endDequeueHere
  499 000001E8         queueEmpty
  500 000001E8 F7FF FFFE       BL               JustSetC    ;run subroutine to set c and then end
  501 000001EC         endDequeueHere
  502 000001EC BD1C            POP              {PC,R2-R4}
  503 000001EE 4770            BX               LR
  504 000001F0                 ENDP
  505 000001F0         
  506 000001F0         Enqueue PROC             {R2-R14}
  507 000001F0         ;****************************************************************
  508 000001F0         ;Description:
  509 000001F0         ; Attempts to put a character in the queue whose queue record structure’s
  510 000001F0         ; address is in R1: if the queue is not full, enqueues the single character 
  511 000001F0         ; from R0 to the queue, and returns with the PSR C bit cleared to report 
  512 000001F0         ; enqueue success, otherwise, returns with the PSR C bit set to report 
  513 000001F0         ; enqueue failure.
  514 000001F0         ;Input Parameter: 
  515 000001F0         ; R0: character to enqueue (unsigned byte ASCII code)
  516 000001F0         ;~~ R1: queue record structure (unsigned word address)
  517 000001F0         ;Output Parameter: 
  518 000001F0         ; R1: queue record structure (unsigned word address)
  519 000001F0         ; C: enqueue operation status: 0 success; 1 failure (PSR bit flag)
  520 000001F0         ;modified registers:
  521 000001F0         ; no registers other than PSR and any output parameters) have changed values
  522 000001F0         ; after return
  523 000001F0         ;subroutines utilized:
  524 000001F0         ; JustClearC
  525 000001F0         ; JustSetC
  526 000001F0         ;****************************************************************
  527 000001F0 B57C            PUSH             {LR,R2-R6}
  528 000001F2 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;R2<-num enqueued (byte)
  529 000001F4 7C0B            LDRB             R3,[R1,#BUF_SIZE] ;R3<-max num Q items (byte)
  530 000001F6 429A            CMP              R2,R3       ;see if queueFull



ARM Macro Assembler    Page 15 Lab Exercise Seven Circular FIFO Queue operations


  531 000001F8 DA11            BGE              queueFull   ;if queueFull go to queueFull
  532 000001FA 680C            LDR              R4,[R1,#IN_PTR] ;R4<-Q IN_PTR
  533 000001FC 7020            STRB             R0,[R4,#0]  ;store char at IN_PTR location 
  534 000001FE 1C52            ADDS             R2,R2,#1    ;increment num_enqued
  535 00000200 744A            STRB             R2,[R1,#NUM_ENQD] ;store updated value
  536 00000202 1C64            ADDS             R4,R4,#1    ;increment IN_PTR past new item
  537 00000204 600C            STR              R4,[R1,#IN_PTR] ;store updated valueof inpointer
  538 00000206 68CD            LDR              R5,[R1,#BUF_PAST] ;R5<-BUF_PAST
  539 00000208 42AC            CMP              R4,R5       ;Compare IN_PTR and BUF_PAST
  540 0000020A D304            BLO              notExceeded ;if IN_PTR less than BUF_PAST: notExceeded
  541 0000020C         ;if queue now full, set inptr to start of queue buffer
  542 0000020C 688E            LDR              R6,[R1,#BUF_STRT] ;R6 <- start Q Buff
  543 0000020E 600E            STR              R6,[R1,#IN_PTR] ;store updated inpointer
  544 00000210 F7FF FFFE       BL               JustClearC  ;indicate successful enqueue
  545 00000214 E005            B                endImmediate
  546 00000216         notExceeded
  547 00000216 600C            STR              R4,[R1,#IN_PTR] ;store updated valueof inpointer
  548 00000218 F7FF FFFE       BL               JustClearC  ;indicate successful enqueue
  549 0000021C E001            B                endImmediate
  550 0000021E         queueFull                            ;set c flag and end
  551 0000021E F7FF FFFE       BL               JustSetC
  552 00000222         endImmediate
  553 00000222 BD7C            POP              {PC,R2-R6}
  554 00000224 4770            BX               LR
  555 00000226                 ENDP
  556 00000226         
  557 00000226         InitQueue
                               PROC             {R0-R14}
  558 00000226         ;****************************************************************
  559 00000226         ;Description:
  560 00000226         ; Initializes the queue record structure at the address in R1 for the empty
  561 00000226         ; queue buffer at the address in R0 of size given in R2, (i.e., character 
  562 00000226         ; capacity).
  563 00000226         ;Input Parameter: 
  564 00000226         ; R0: queue buffer (unsigned word address)
  565 00000226         ; R1: queue record structure (unsigned word address)
  566 00000226         ; R2: queue capacity in bytes (unsigned byte value)
  567 00000226         ;Output Parameter: none
  568 00000226         ;modified registers:
  569 00000226         ; no registers other than PSR and any output parameters) have changed values
  570 00000226         ; after return
  571 00000226         ;****************************************************************



ARM Macro Assembler    Page 16 Lab Exercise Seven Circular FIFO Queue operations


  572 00000226 B407            PUSH             {R0-R2}
  573 00000228 6008            STR              R0,[R1,#IN_PTR] ;store addr in ptr of Q in rec struct  
  574 0000022A 6048            STR              R0,[R1,#OUT_PTR] ;store addr out ptr of Q in rec struct 
  575 0000022C 6088            STR              R0,[R1,#BUF_STRT] ;store addr Q start in rec struct 
  576 0000022E 1880            ADDS             R0,R0,R2    ;R0 = R0 + Q capacity
  577 00000230 60C8            STR              R0,[R1,#BUF_PAST] ;str 1st addr past Q buff end
  578 00000232 740A            STRB             R2,[R1,#BUF_SIZE] ;store Q capacity in rec struct
  579 00000234 2000            MOVS             R0,#0       ;R0 = 0
  580 00000236 7448            STRB             R0,[R1,#NUM_ENQD] ;store that nothing enqueued so far
  581 00000238 BC07            POP              {R0-R2}
  582 0000023A 4770            BX               LR
  583 0000023C                 ENDP
  584 0000023C         
  585 0000023C         PutNumHex
                               PROC             {R0-R14}
  586 0000023C         ;****************************************************************
  587 0000023C         ;Description:
  588 0000023C         ; Prints to the terminal screen the text hexadecimal representation of the
  589 0000023C         ; unsigned word value in R0. (For example, if R0 contains 0x000012FF, then 
  590 0000023C         ; 000012FF should print on the terminal. Note: 12FF would not be acceptable. 
  591 0000023C         ; Do not use division to determine the hexadecimal digit values—use bit masks 
  592 0000023C         ; and shifts.)
  593 0000023C         ;Input Parameter: 
  594 0000023C         ; R0: number to print in hexadecimal (unsigned word value)
  595 0000023C         ;Output Parameter: none
  596 0000023C         ;modified registers:
  597 0000023C         ; no registers other than PSR and any output parameters) have changed values
  598 0000023C         ; after return
  599 0000023C         ;subroutines utilized:
  600 0000023C         ; PutChar
  601 0000023C         ;****************************************************************
  602 0000023C B5FF            PUSH             {LR,R0-R7}
  603 0000023E 0002            MOVS             R2,R0       ;copy unsigned word value to r2
  604 00000240 2308            MOVS             R3,#8       ;move 8 to r3 as a comparator
  605 00000242 2400            MOVS             R4,#0       ;move 0 to r4 as a loop counter (i)
  606 00000244         ;need to put #0xFFFFFFF0 in r6 as clearing mask
  607 00000244 260F            MOVS             R6,#2_0000000000001111 ;will try just like this
  608 00000246         
  609 00000246         
  610 00000246 2709            MOVS             R7,#9       ;comporator for ascii
  611 00000248         convertLoopHex
  612 00000248 2504            MOVS             R5,#4       ;move 4 to R5 as a multiplication const.



ARM Macro Assembler    Page 17 Lab Exercise Seven Circular FIFO Queue operations


  613 0000024A 0010            MOVS             R0,R2       ;restore original hex value
  614 0000024C 4365            MULS             R5,R4,R5    ;R5<-4*1
  615 0000024E 40E8            LSRS             R0,R0,R5    ;shift right 4*i bits(=1 nibble= 1 hex char)
  616 00000250         ;and pad with zeros on the left
  617 00000250 4030            ANDS             R0,R0,R6    ;clear all but LSB of R0
  618 00000252 42B8            CMP              R0,R7       ;compare single hex digit with 
  619 00000254 DD01            BLE              hexLessThan9 ;if 9 or less just add 0x30
  620 00000256 2137            MOVS             R1,#0x37    ;if  >9, add 0x32 (idk why not 0x40) 
  621 00000258 E000            B                nowConvert
  622 0000025A         hexLessThan9
  623 0000025A 2130            MOVS             R1,#0x30    ;ascii conversion mask
  624 0000025C         nowConvert
  625 0000025C 1840            ADDS             R0,R0,R1    ;convert hex character to ascii
  626 0000025E B401            PUSH             {R0}        ;push R0 to print later in reverse order
  627 00000260 1C64            ADDS             R4,R4,#1    ;increment i
  628 00000262 42A3            CMP              R3,R4
  629 00000264 D000            BEQ              endConvertHex ;once counter equal to 8 its done   
  630 00000266 E7EF            B                convertLoopHex
  631 00000268         endConvertHex
  632 00000268         ;pop 8 times from the stack and print using putchar (LIFO)
  633 00000268 2400            MOVS             R4,#0       ;new loop counter n at 0
  634 0000026A         LIFOPrintLoop
  635 0000026A 42A3            CMP              R3,R4       ;compare n to 8
  636 0000026C D004            BEQ              finishedLIFOPrint ;when equal stop print looping
  637 0000026E BC01            POP              {R0}
  638 00000270 F7FF FFFE       BL               PutChar
  639 00000274 1C64            ADDS             R4,R4,#1    ;increment n
  640 00000276 E7F8            B                LIFOPrintLoop
  641 00000278         finishedLIFOPrint
  642 00000278 BDFF            POP              {PC,R0-R7}
  643 0000027A 4770            BX               LR
  644 0000027C                 ENDP
  645 0000027C         
  646 0000027C         PutNumUB
                               PROC             {R0-R14}
  647 0000027C         ;****************************************************************
  648 0000027C         ;Description:
  649 0000027C         ; Prints to the terminal screen the text decimal representation of the
  650 0000027C         ; unsigned byte value in R0. (For example, if R0 contains 0x003021101, 
  651 0000027C         ; then 1 should print on the terminal. Note: 001 would also be acceptable, 
  652 0000027C         ; as the text decimal representation of 0x01.) (Hint: use a mask to preserve 
  653 0000027C         ; only the least byte of the word in R0, and call your PutNumU subroutine



ARM Macro Assembler    Page 18 Lab Exercise Seven Circular FIFO Queue operations


  654 0000027C         ; from Lab Exercise Six.)
  655 0000027C         ;Input Parameter: 
  656 0000027C         ; R0: number to print in decimal (unsigned byte value)
  657 0000027C         ;Output Parameter: none
  658 0000027C         ;modified registers:
  659 0000027C         ; no registers other than PSR and any output parameters) have changed values
  660 0000027C         ; after return
  661 0000027C         ;subroutines utilized:
  662 0000027C         ; PutNumU
  663 0000027C         ;****************************************************************
  664 0000027C B503            PUSH             {LR,R0-R1}
  665 0000027E 210F            MOVS             R1,#2_00001111 ;put mask into r1-1
  666 00000280 B249            SXTB             R1,R1       ;sign extend to finish
  667 00000282 4008            ANDS             R0,R0,R1    ;AND with the mask to preserve only LSB
  668 00000284 F7FF FFFE       BL               PutNumU     ;use PutNumU to print the byte
  669 00000288 BD03            POP              {PC,R0-R1}
  670 0000028A 4770            BX               LR
  671 0000028C                 ENDP
  672 0000028C         
  673 0000028C         PutNumU PROC             {R0-R14}
  674 0000028C         ;****************************************************************
  675 0000028C         ;Displays text decimal representation of value to terminal screen
  676 0000028C         ;This subroutine displays the text decimal representation to the
  677 0000028C         ;terminal screen of the unsigned word value in R0, using PutChar 
  678 0000028C         ;to output each decimal digit character. (For example, if R0 
  679 0000028C         ;contains 0x00000100, then 256 should be output 0000000256 would 
  680 0000028C         ;also be acceptable.) (hint use divU)
  681 0000028C         ;Input Parameters: 
  682 0000028C         ;R0: number for output to terminal(unsigned word value)
  683 0000028C         ;Output Parameter:
  684 0000028C         ; none
  685 0000028C         ;no registers but PSR changed after return
  686 0000028C         ;Subroutines used:
  687 0000028C         ; DIVU
  688 0000028C         ; PutChar
  689 0000028C         ;****************************************************************
  690 0000028C B53F            PUSH             {LR,R0-R5}
  691 0000028E 0002            MOVS             R2,R0       ;backup word value in R2
  692 00000290 230A            MOVS             R3,#10      ;store 10 to be the denominator
  693 00000292 2400            MOVS             R4,#0       ;store counter in R4
  694 00000294 0011            MOVS             R1,R2       ;move word value to numerator
  695 00000296         convertLoop



ARM Macro Assembler    Page 19 Lab Exercise Seven Circular FIFO Queue operations


  696 00000296 0018            MOVS             R0,R3       ;move 10 to be the denominator
  697 00000298         
  698 00000298 F7FF FFFE       BL               DIVU        ;use DIVU    
  699 0000029C B402            PUSH             {R1}        ;store the remainder in the stack
  700 0000029E 1C64            ADDS             R4,R4,#1    ;increment counter
  701 000002A0 0001            MOVS             R1,R0       ;move the quotient so that it will be the ~~~~
  702 000002A2         ;numerator next time around
  703 000002A2 2800            CMP              R0,#0       ;check if quotient is 0, if so done
  704 000002A4 D1F7            BNE              convertLoop ;if quotient not equal 0 go again
  705 000002A6         popLoop
  706 000002A6 BC01            POP              {R0}        ;pop individual result to the register r0
  707 000002A8 2530            MOVS             R5,#0x30    ;move hex 30 into the register
  708 000002AA 1940            ADDS             R0,R0,R5    ;add to r0 to make ascii from dec
  709 000002AC F7FF FFFE       BL               PutChar     ;use putchar to output to the terminal  
  710 000002B0 1E64            SUBS             R4,R4,#1    ;decrement counter
  711 000002B2 2C00            CMP              R4,#0       ;see if counter is back to 0
  712 000002B4 DCF7            BGT              popLoop     ;if counter still positive loop again  
  713 000002B6 BD3F            POP              {PC,R0-R5}  ;restore registers
  714 000002B8 4770            BX               LR          ;branch back to where putNumU was called
  715 000002BA                 ENDP
  716 000002BA         
  717 000002BA         DIVU    PROC             {R2-R14}
  718 000002BA         ;****************************************************************
  719 000002BA         ;Subroutine from lab 4 created to perform integer division
  720 000002BA         ;Input: Parameters:
  721 000002BA         ; R0: divisor (denominator)
  722 000002BA         ; R1: dividend (numerator)
  723 000002BA         ;Output Parameters
  724 000002BA         ; R0: quotient
  725 000002BA         ; R1: remainder
  726 000002BA         ; C: APSR flag: 0 for valid result; 1 for invalid result
  727 000002BA         ;****************************************************************
  728 000002BA 2800            CMP              R0,#0       ;check if divisor (denominator) is already zero
  729 000002BC D015            BEQ              div0        ;if so branch to div0 to set c flag
  730 000002BE B40C            PUSH             {R2,R3}     ;store R2 and R3 on the stack
  731 000002C0 2900            CMP              R1,#0       ;check if dividend(numerator) is zero
  732 000002C2 D007            BEQ              zerodiv     ;if so set outputs to 0 and clear C flag
  733 000002C4         
  734 000002C4         ;actual division part
  735 000002C4 2200            MOVS             R2,#0       ;quotient =0 (R2 will be quotient while computing)
  736 000002C6         divuloop
  737 000002C6 4281            CMP              R1,R0       ;while dividend>=divisor



ARM Macro Assembler    Page 20 Lab Exercise Seven Circular FIFO Queue operations


  738 000002C8 D302            BLO              divuFinish
  739 000002CA 1A09            SUBS             R1,R1,R0    ;dividend=dividend-divisor
  740 000002CC 1C52            ADDS             R2,R2,#1    ;quotient=quotient+1
  741 000002CE E7FA            B                divuloop
  742 000002D0         divuFinish
  743 000002D0 0010            MOVS             R0,R2       ;R0 =quotient = p
  744 000002D2         ;R1 = remainder = dividend = q
  745 000002D2 E001            B                clearC      ;branch and clearC then endit
  746 000002D4         zerodiv                              ;if dividing zero by anything the result is 0 rem 0
  747 000002D4 2000            MOVS             R0,#0
  748 000002D6 2100            MOVS             R1,#0
  749 000002D8         clearC
  750 000002D8 F3EF 8200       MRS              R2,APSR
  751 000002DC 2320            MOVS             R3,#0x20
  752 000002DE 061B            LSLS             R3,R3,#24
  753 000002E0 439A            BICS             R2,R2,R3
  754 000002E2 F382 8800       MSR              APSR,R2
  755 000002E6 BC0C            POP              {R2,R3}     ;restore R2 and R3 from stack
  756 000002E8 E001            B                endit
  757 000002EA         div0                                 ;time to set the C flag and leave all else unchanged
  758 000002EA F7FF FFFE       BL               JustSetC
  759 000002EE         endit
  760 000002EE 4770            BX               LR
  761 000002F0                 ENDP
  762 000002F0         
  763 000002F0         
  764 000002F0         Init_UART0_Polling
                               PROC             {R0-R14}
  765 000002F0         ;****************************************************************
  766 000002F0         ;select/configure UART0 sources 
  767 000002F0         ;enable clocks for UART0 and Port B
  768 000002F0         ;set Port B mux pins to connect to UART0 
  769 000002F0         ;Configure UART0 (register initialization)
  770 000002F0         ;Input Parameter: none
  771 000002F0         ;Output Parameter: none
  772 000002F0         ;no registers but LR, PC, PSR changed after return
  773 000002F0         ;****************************************************************
  774 000002F0 B407            PUSH             {R0-R2}
  775 000002F2         ;code copied from provided PDF
  776 000002F2         ;Select MCGFLLCLK as UART0 clock source
  777 000002F2 4841            LDR              R0,=SIM_SOPT2
  778 000002F4 4941            LDR              R1,=SIM_SOPT2_UART0SRC_MASK



ARM Macro Assembler    Page 21 Lab Exercise Seven Circular FIFO Queue operations


  779 000002F6 6802            LDR              R2,[R0,#0]
  780 000002F8 438A            BICS             R2,R2,R1
  781 000002FA 4941            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCLK
  782 000002FC 430A            ORRS             R2,R2,R1
  783 000002FE 6002            STR              R2,[R0,#0]
  784 00000300         ;Set UART0 for external connection
  785 00000300 4840            LDR              R0,=SIM_SOPT5
  786 00000302 4941            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  787 00000304 6802            LDR              R2,[R0,#0]
  788 00000306 438A            BICS             R2,R2,R1
  789 00000308 6002            STR              R2,[R0,#0]
  790 0000030A         ;Enable UART0 module clock
  791 0000030A 4840            LDR              R0,=SIM_SCGC4
  792 0000030C 4940            LDR              R1,=SIM_SCGC4_UART0_MASK
  793 0000030E 6802            LDR              R2,[R0,#0]
  794 00000310 430A            ORRS             R2,R2,R1
  795 00000312 6002            STR              R2,[R0,#0]
  796 00000314         ;Enable PORT B module clock
  797 00000314 483F            LDR              R0,=SIM_SCGC5
  798 00000316 493E            LDR              R1,=SIM_SCGC5_PORTB_MASK
  799 00000318 6802            LDR              R2,[R0,#0]
  800 0000031A 430A            ORRS             R2,R2,R1
  801 0000031C 6002            STR              R2,[R0,#0]
  802 0000031E         ;Select PORT B Pin 2 (D0) for UART0 RX (J8 Pin 01)
  803 0000031E 483E            LDR              R0,=PORTB_PCR2
  804 00000320 493E            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  805 00000322 6001            STR              R1,[R0,#0]
  806 00000324         ; Select PORT B Pin 1 (D1) for UART0 TX (J8 Pin 02)
  807 00000324 483E            LDR              R0,=PORTB_PCR1
  808 00000326 493D            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  809 00000328 6001            STR              R1,[R0,#0]
  810 0000032A         ;Disable UART0 receiver and transmitter
  811 0000032A 483E            LDR              R0,=UART0_BASE
  812 0000032C 210C            MOVS             R1,#UART0_C2_T_R
  813 0000032E 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  814 00000330 438A            BICS             R2,R2,R1
  815 00000332 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  816 00000334         ;Set UART0 for 9600 baud, 8N1 protocol
  817 00000334 2101            MOVS             R1,#UART0_BDH_9600
  818 00000336 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  819 00000338 2138            MOVS             R1,#UART0_BDL_9600
  820 0000033A 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]



ARM Macro Assembler    Page 22 Lab Exercise Seven Circular FIFO Queue operations


  821 0000033C 2100            MOVS             R1,#UART0_C1_8N1
  822 0000033E 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  823 00000340 2100            MOVS             R1,#UART0_C3_NO_TXINV
  824 00000342 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  825 00000344 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  826 00000346 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  827 00000348 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  828 0000034A 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  829 0000034C 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  830 0000034E 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  832 00000350 21C0            MOVS             R1,       #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  833 00000352 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  834 00000354         ;Enable UART0 receiver and transmitter
  835 00000354 210C            MOVS             R1,#UART0_C2_T_R
  836 00000356 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  837 00000358         ;end code from PDF
  838 00000358 BC07            POP              {R0-R2}
  839 0000035A 4770            BX               LR
  840 0000035C                 ENDP
  841 0000035C         
  842 0000035C         
  843 0000035C         PutChar PROC             {R0-R14}
  844 0000035C         ;****************************************************************
  845 0000035C         ;Polled Transmit 
  846 0000035C         ;Description from provided doc:
  847 0000035C         ;A polled transmit, (i.e., send character), polls UART0 status 
  848 0000035C         ;register 1 for the transmit data register empty (TDRE) condition 
  849 0000035C         ;in bit 7. If TDRE = 1, a byte may be transmitted (i.e., sent); 
  850 0000035C         ;otherwise, UART0 is not yet ready to transmit a byte, and the
  851 0000035C         ;status register must be polled until TDRE = 1.
  852 0000035C         ;Input Parameter: 
  853 0000035C         ; R0:  character to send to terminal (unsigned byte ASCII code)
  854 0000035C         ;Output Parameter: none
  855 0000035C         ;no registers but LR, PC, PSR changed after return
  856 0000035C         ;****************************************************************
  857 0000035C         ;code from pdf
  858 0000035C         ;Poll TDRE until UART0 ready to transmit
  859 0000035C B40F            PUSH             {R0-R3}
  860 0000035E 4931            LDR              R1,=UART0_BASE
  861 00000360 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  862 00000362 790B    PollTx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  863 00000364 4013            ANDS             R3,R3,R2



ARM Macro Assembler    Page 23 Lab Exercise Seven Circular FIFO Queue operations


  864 00000366 D0FC            BEQ              PollTx
  865 00000368         ;Transmit character stored in R0
  866 00000368 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  867 0000036A BC0F            POP              {R0-R3}
  868 0000036C 4770            BX               LR
  869 0000036E                 ENDP
  870 0000036E         
  871 0000036E         GetChar PROC             {R1-R14}
  872 0000036E         ;****************************************************************
  873 0000036E         ;Polled Recieve 
  874 0000036E         ;Description from provided doc:
  875 0000036E         ;a polled receive, (i.e., get character), polls UART0 status 
  876 0000036E         ;register 1 for the receive data register full (RDRF) condition 
  877 0000036E         ;in bit 5. If RDRF = 1, a byte may be read by the KL05, 
  878 0000036E         ;(i.e., received); otherwise, UART0 has not yet received a 
  879 0000036E         ;byte, and the status register must be polled until RDRF = 1.
  880 0000036E         ;Input Parameter: none
  881 0000036E         ;Output Parameter: 
  882 0000036E         ; R0: character recieved from terminal (unsigned byte ASCII code)
  883 0000036E         ;no registers but R0, LR, PC, PSR changed after return
  884 0000036E         ;****************************************************************
  885 0000036E         ;code from doc provided
  886 0000036E B40E            PUSH             {R1-R3}
  887 00000370         ;Poll RDRF until UART0 ready to receive
  888 00000370 492C            LDR              R1,=UART0_BASE
  889 00000372 2220            MOVS             R2,#UART0_S1_RDRF_MASK
  890 00000374 790B    PollRx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  891 00000376 4013            ANDS             R3,R3,R2
  892 00000378 D0FC            BEQ              PollRx
  893 0000037A         ;Receive character and store in R0
  894 0000037A 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  895 0000037C BC0E            POP              {R1-R3}
  896 0000037E 4770            BX               LR
  897 00000380                 ENDP
  898 00000380         ;unused    
  899 00000380         ;GetStringSB PROC {R1-R14}
  900 00000380         ;;****************************************************************
  901 00000380         ;;Inputs string from terminal reventing overrun 
  902 00000380         ; ;Preventing overrun of the buffer capacity specified in R1, this
  903 00000380         ;;subroutine inputs a string from the terminal keyboard to memory 
  904 00000380         ;;starting at the address in R0 and adds null termination. It ends 
  905 00000380         ;;terminal keyboard input when the user presses the enter key. 



ARM Macro Assembler    Page 24 Lab Exercise Seven Circular FIFO Queue operations


  906 00000380         ;;For each of up to R1 - 1 characters typed on the terminal 
  907 00000380         ;;keyboard, it uses GetChar to input the character, uses PutChar 
  908 00000380         ;;to echo the character to the terminal screen, and stores the 
  909 00000380         ;;character at the next position in the string. For any character
  910 00000380         ;;typed after the first R1 - 1 characters, it uses GetChar to input 
  911 00000380         ;;the character, but it neither stores the character in the string 
  912 00000380         ;;nor echoes the character to the terminal screen.When the carriage 
  913 00000380         ;;return character has been received, it null terminates the string,
  914 00000380         ;;advances the cursor on the terminal screen to the beginning of 
  915 00000380         ;;the next line, and returns.
  916 00000380         ;;Input Parameter: 
  917 00000380         ;;~~~R0: should be mem adress to start at. Not specified in doc
  918 00000380         ;; R1: bytes in string buffer where R0 points(unsigned word value)
  919 00000380         ;;Output Parameter: 
  920 00000380         ;; R0: string buffer in memory for input from user (unsigned word 
  921 00000380         ;;  address)
  922 00000380         ;;no registers but PSR changed after return
  923 00000380         ;;Subroutines used:
  924 00000380         ;; GetChar
  925 00000380         ;; PutChar
  926 00000380         ;;****************************************************************
  927 00000380         ;   PUSH {LR,R0-R5}
  928 00000380         ;   MOVS R3,R0  ;copy address to store in to R3
  929 00000380         ;   SUBS R4,R1,#1 ;store R1-1 in R4
  930 00000380         ;   MOVS R2,#0  ;initialize r2 as 0 for num chars typed
  931 00000380         ;loopHere 
  932 00000380         ;   BL  GetChar  ;Get char from terminal (now in R0)
  933 00000380         ;   MOVS R5,R2  ;r5 1 less then r2 for storage purposes
  934 00000380         ;   ADDS R2,R2,#1 ;increment r2
  935 00000380         ;   
  936 00000380         ;   CMP  R0,#CR  ;compare the character typed to carriage return
  937 00000380         ;   BEQ  enterPressed;if equal branch accordingly
  938 00000380         ;   
  939 00000380         ;   CMP  R2,R4  ;compare r1-1 with num chars typed so far
  940 00000380         ;   BGT  loopHere ;if r2 > r4 then no output or store
  941 00000380         ;   
  942 00000380         ;   ;output and store 
  943 00000380         ;   BL  PutChar  ;output char in r0 to terminal
  944 00000380         ;   STRB R0,[R3,R5]  ;store in addr r0 inc offset
  945 00000380         ;   B  loopHere
  946 00000380         ;   
  947 00000380         ;enterPressed



ARM Macro Assembler    Page 25 Lab Exercise Seven Circular FIFO Queue operations


  948 00000380         ;   LDR  R0,=lenOpStr;load address to store the length of op str in
  949 00000380         ;   CMP  R5,R4  ;if length greater than max length
  950 00000380         ;   BLE  notExceed
  951 00000380         ;   MOVS R5,R4  ;store length as max length
  952 00000380         ;notExceed
  953 00000380         ;   STRB R5,[R0,#0] ;store the length of the op str 
  954 00000380         ;   MOVS R0,#NULL ;move equate null into r0 
  955 00000380         ;   STRB R0,[R3,R5]  ;store null in addr r0 inc offset
  956 00000380         ;   
  957 00000380         ;   POP  {PC,R0-R5}
  958 00000380         ;   BX  LR
  959 00000380         ;   ENDP   
  960 00000380         
  961 00000380         PutStringSB
                               PROC             {R0-R14}
  962 00000380         ;****************************************************************
  963 00000380         ;Displays string from memory to terminal screen
  964 00000380         ;Preventing overrun of the buffer capacity specified in R1, 
  965 00000380         ;this subroutine displays a null-terminated string to the terminal 
  966 00000380         ;screen from memory starting at the address in R0. It uses PutChar 
  967 00000380         ;to display characters from the string and leaves the terminal 
  968 00000380         ;screen cursor positioned after the last character of the string.
  969 00000380         ;Input Parameters: 
  970 00000380         ; R0: string buffer in memory for output to simulated output stream 
  971 00000380         ; (unsigned word address)
  972 00000380         ; R1: bytes in string buffer where R0 points (unsigned word value)
  973 00000380         ;Output Parameter:
  974 00000380         ; none
  975 00000380         ;no registers but PSR changed after return
  976 00000380         ;Subroutines used:
  977 00000380         ; PutChar
  978 00000380         ;****************************************************************
  979 00000380         
  980 00000380 B50F            PUSH             {LR,R0-R3}
  981 00000382 0002            MOVS             R2,R0       ;copy starting address of string
  982 00000384 2300            MOVS             R3,#0       ;initialize counter
  983 00000386         printLoop
  984 00000386 5CD0            LDRB             R0,[R2,R3]  ;configure input to PutChar correctly with
  985 00000388         ;offset
  986 00000388 2800            CMP              R0,#NULL    ;compare to see if null character an
  987 0000038A D004            BEQ              stopPrint   ;if so terminate
  988 0000038C         



ARM Macro Assembler    Page 26 Lab Exercise Seven Circular FIFO Queue operations


  989 0000038C F7FF FFFE       BL               PutChar     ;use putchar to output char R0 to terminal   
  990 00000390         
  991 00000390 1C5B            ADDS             R3,R3,#1    ;increment counter
  992 00000392 428B            CMP              R3,R1
  993 00000394 DDF7            BLE              printLoop   ;if the counter is less than or equal to the 
  994 00000396         stopPrint                            ;num bytes in the string branch and get next
  995 00000396 BD0F            POP              {PC,R0-R3}  ;otherwise restore registers and exit
  996 00000398 4770            BX               LR
  997 0000039A                 ENDP
  998 0000039A         ;>>>>>   end subroutine code <<<<<
  999 0000039A 00 00           ALIGN
 1000 0000039C         ;****************************************************************
 1001 0000039C         ;Vector Table Mapped to Address 0 at Reset
 1002 0000039C         ;Linker requires __Vectors to be exported
 1003 0000039C 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 



ARM Macro Assembler    Page 27 Lab Exercise Seven Circular FIFO Queue operations


              40048034 
              00000400 
              40048038 
              4004A008 
              01000200 
              4004A004 
              4006A000         AREA             RESET, DATA, READONLY
 1004 00000000                 EXPORT           __Vectors
 1005 00000000                 EXPORT           __Vectors_End
 1006 00000000                 EXPORT           __Vectors_Size
 1007 00000000                 IMPORT           __initial_sp
 1008 00000000                 IMPORT           Dummy_Handler
 1009 00000000                 IMPORT           HardFault_Handler
 1010 00000000         __Vectors
 1011 00000000         ;ARM core vectors
 1012 00000000 00000000        DCD              __initial_sp ;00:end of stack
 1013 00000004 00000000        DCD              Reset_Handler ;01:reset vector
 1014 00000008 00000000        DCD              Dummy_Handler ;02:NMI
 1015 0000000C 00000000        DCD              HardFault_Handler ;03:hard fault
 1016 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
 1017 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
 1018 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
 1019 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
 1020 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
 1021 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
 1022 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
 1023 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
 1024 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
 1025 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
 1026 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (PendableSrvReq)
 1027 0000003C         ;   pendable request 
 1028 0000003C         ;   for system service)
 1029 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
 1030 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 transfer 
 1031 00000044         ;   complete/error
 1032 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 transfer
 1033 00000048         ;   complete/error
 1034 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 transfer
 1035 0000004C         ;   complete/error
 1036 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 transfer
 1037 00000050         ;   complete/error
 1038 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)



ARM Macro Assembler    Page 28 Lab Exercise Seven Circular FIFO Queue operations


 1039 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command complete/
 1040 00000058         ;   read collision
 1041 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
 1042 0000005C         ;   low-voltage warning
 1043 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
 1044 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1045 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
 1046 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
 1047 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
 1048 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status; error)
 1049 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
 1050 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
 1051 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1052 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1053 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1054 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1055 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
 1056 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1057 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
 1058 00000098 00000000        DCD              Dummy_Handler ;38:PIT
 1059 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
 1060 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)
 1061 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1062 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1063 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1064 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1065 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
 1066 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
 1067 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
 1068 000000C0         __Vectors_End
 1069 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1070 000000C0                 ALIGN
 1071 000000C0         ;****************************************************************
 1072 000000C0         ;Constants
 1073 000000C0                 AREA             MyConst,DATA,READONLY
 1074 00000000         ;>>>>> begin constants here <<<<<
 1075 00000000 54 79 70 
              65 20 61 
              20 71 75 
              65 75 65 



ARM Macro Assembler    Page 29 Lab Exercise Seven Circular FIFO Queue operations


              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 44 2C 
              45 2C 48 
              2C 50 2C 
              53 29 3A PROMPT_QUEUE
                               DCB              "Type a queue command (D,E,H,P,S):"
 1076 00000021 46 61 69 
              6C 75 72 
              65 3A    FAILURE_STR
                               DCB              "Failure:"
 1077 00000029 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A ENQUEUE_STR
                               DCB              "Character to enqueue:"
 1078 0000003E 53 75 63 
              63 65 73 
              73 3A    SUCCESS_STR
                               DCB              "Success:"
 1079 00000046 53 74 61 
              74 75 73 
              3A       STATUS_STR
                               DCB              "Status:"
 1080 0000004D 49 6E 3D 
              30 78    IN_STR  DCB              "In=0x"
 1081 00000052 20 20 20 
              4F 75 74 
              3D 30 78 OUT_STR DCB              "   Out=0x"
 1082 0000005B 4E 75 6D 
              3D       NUM_STR DCB              "Num="
 1083 0000005F         
 1085 0000005F 44 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 45 20 
              28 65 6E 



ARM Macro Assembler    Page 30 Lab Exercise Seven Circular FIFO Queue operations


              71 75 65 
              75 65 29 
              2C 20 48 
              20 28 68 
              65 6C 70 
              29 2C 20 
              50 20 28 
              70 72 69 
              6E 74 29 
              2C 20 53 
              20 28 73 
              74 61 74 
              75 73 29 HELP_STR
                               DCB              "D (dequeue), E (enqueue), H (help), P (print), S (status)"
 1086 00000098 20 20   SPACES2 DCB              "  "
 1087 0000009A 20 20 20 
              20 20 20 
              20 20    SPACES8 DCB              "        "
 1088 000000A2         ;>>>>>   end constants here <<<<<
 1089 000000A2 00 00           ALIGN
 1090 000000A4         ;****************************************************************
 1091 000000A4         ;Variables
 1092 000000A4                 AREA             MyData,DATA,READWRITE
 1093 00000000         ;>>>>> begin variables here <<<<<
 1094 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QRecord SPACE            Q_REC_SZ    ;allocate 18 bytes to variable QRecord
 1095 00000012 00 00 00 
              00       QBuffer SPACE            Q_BUF_SZ    ;allocate 4  bytes to variable QBuffer
 1096 00000016         ;>>>>>   end variables here <<<<<
 1097 00000016 00 00           ALIGN
 1098 00000018                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\objects\
exercise07.d -o.\objects\exercise07.o -IC:\Users\Atticus\AppData\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Inc
lude -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSION SETA 531" --predefine="MK
L05Z32xxx4 SETA 1" --list=.\listings\exercise07.lst Exercise07.s
