


ARM Macro Assembler    Page 1 Lab Exercise Nine Serial I/O Driver


    1 00000000                 TTL              Lab Exercise Nine Serial I/O Dr
iver
    2 00000000         ;*******************************************************
                       *********
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;(What does the program do?)
    5 00000000         ;Name:  <Atticus Russell>
    6 00000000         ;Date:  <4/1/2021>
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  <Section 01L1, Thursday, 2:00-3:55>
    9 00000000         ;-------------------------------------------------------
                       --------
   10 00000000         ;Keil Template for KL05
   11 00000000         ;R. W. Melton
   12 00000000         ;September 13, 2020
   13 00000000         ;*******************************************************
                       *********
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;*******************************************************
                       *********
   18 00000000         ;Include files
   19 00000000                 GET              MKL05Z4.s   ;Included by start.
                                                            s
   21 00000000         ;*******************************************************
                       *********
   22 00000000         ;EQUates
   23 00000000         
   24 00000000         ;Below EQUates are from lab exercise 7
   25 00000000         ;-------------------------------------------------------
                       --------
   26 00000000         ; Queue management record field offsets
   27 00000000 00000000 
                       IN_PTR  EQU              0
   28 00000000 00000004 
                       OUT_PTR EQU              4
   29 00000000 00000008 
                       BUF_STRT
                               EQU              8
   30 00000000 0000000C 
                       BUF_PAST
                               EQU              12
   31 00000000 00000010 
                       BUF_SIZE
                               EQU              16
   32 00000000 00000011 
                       NUM_ENQD
                               EQU              17
   33 00000000         ; Queue structure sizes
   34 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4           ;Queue contents
   35 00000000 00000012 
                       Q_REC_SZ
                               EQU              18          ;Queue management r
                                                            ecord
   36 00000000         ; Number of bytes in prompts
   37 00000000 00000020 
                       PROMPT_QUEUE_LEN



ARM Macro Assembler    Page 2 Lab Exercise Nine Serial I/O Driver


                               EQU              32          ;
   38 00000000 00000007 
                       FAILURE_STR_LEN
                               EQU              7           ;
   39 00000000 00000014 
                       ENQUEUE_STR_LEN
                               EQU              20          ;
   40 00000000 00000007 
                       SUCCESS_STR_LEN
                               EQU              7           ;
   41 00000000 00000006 
                       STATUS_STR_LEN
                               EQU              6           ;
   42 00000000 00000004 
                       IN_STR_LEN
                               EQU              4           ;
   43 00000000 00000008 
                       OUT_STR_LEN
                               EQU              8           ;
   44 00000000 00000003 
                       NUM_STR_LEN
                               EQU              3           ;
   45 00000000 00000038 
                       HELP_STR_LEN
                               EQU              56          ;
   46 00000000         ;-------------------------------------------------------
                       --------
   47 00000000         ;For text output and related subroutines
   48 00000000 0000000D 
                       CR      EQU              0x0D        ;moves cursor begin
                                                            ning line
   49 00000000 0000000A 
                       LF      EQU              0x0A        ;adds new line
   50 00000000 00000000 
                       NULL    EQU              0x00        ;the null character
                                                            
   51 00000000         ;below equates are from "useful EQUates for UART0 serial
                        driver"
   52 00000000         ;-------------------------------------------------------
                       --------
   53 00000000         ;NVIC_ICER
   54 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
   55 00000000         ;             read:   0 = unmasked;   1 = masked
   56 00000000         ;             write:  0 = no effect;  1 = mask
   57 00000000         ;12:UART0 IRQ mask
   58 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   59 00000000         ;-------------------------------------------------------
                       --------
   60 00000000         ;NVIC_ICPR
   61 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
   62 00000000         ;             read:   0 = not pending;  1 = pending
   63 00000000         ;             write:  0 = no effect;
   64 00000000         ;                     1 = change status to not pending
   65 00000000         ;12:UART0 IRQ pending status
   66 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK



ARM Macro Assembler    Page 3 Lab Exercise Nine Serial I/O Driver


   67 00000000         ;-------------------------------------------------------
                       --------
   68 00000000         ;NVIC_IPR0-NVIC_IPR7
   69 00000000         ;2-bit priority:  00 = highest; 11 = lowest
   70 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
   71 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
   72 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PR
I_POS)
   73 00000000         ;-------------------------------------------------------
                       --------
   74 00000000         ;NVIC_ISER
   75 00000000         ;31-00:SETENA=masks for HW IRQ sources;
   76 00000000         ;             read:   0 = masked;     1 = unmasked
   77 00000000         ;             write:  0 = no effect;  1 = unmask
   78 00000000         ;12:UART0 IRQ mask
   79 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   80 00000000         ;-------------------------------------------------------
                       --------
   81 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   82 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   83 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   84 00000000         ;-------------------------------------------------------
                       --------
   85 00000000         ;Port B
   87 00000000 01000200 
                       PORT_PCR_SET_PTB2_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   89 00000000 01000200 
                       PORT_PCR_SET_PTB1_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   90 00000000         ;-------------------------------------------------------
                       --------
   91 00000000         ;SIM_SCGC4
   92 00000000         ;1->10:UART0 clock gate control (enabled)
   93 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   94 00000000         ;-------------------------------------------------------
                       --------
   95 00000000         ;SIM_SCGC5
   96 00000000         ;1->10:Port B clock gate control (enabled)
   97 00000000         ;Use provided SIM_SCGC5_PORTB_MASK
   98 00000000         ;-------------------------------------------------------
                       --------
   99 00000000         ;SIM_SOPT2
  100 00000000         ;01=27-26:UART0SRC=UART0 clock source select (MCGFLLCLK)
                       
  101 00000000         ;-------------------------------------------------------
                       --------
  103 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGFLLCLK



ARM Macro Assembler    Page 4 Lab Exercise Nine Serial I/O Driver


                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
  104 00000000         ;-------------------------------------------------------
                       --------
  105 00000000         ;SIM_SOPT5
  106 00000000         ; 0->   16:UART0 open drain enable (disabled)
  107 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
  108 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
  112 00000000 00010005 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:  
                                SIM_SOPT5_UART0RXSRC_MASK :OR:               
                   SIM_SOPT5_UART0TXSRC_MASK)
  113 00000000         ;-------------------------------------------------------
                       --------
  114 00000000         ;UART0_BDH
  115 00000000         ;    0->  7:LIN break detect IE (disabled)
  116 00000000         ;    0->  6:RxD input active edge IE (disabled)
  117 00000000         ;    0->  5:Stop bit number select (1)
  118 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
  119 00000000         ;UART0CLK is MCGFLLCLK
  120 00000000         ;MCGFLLCLK is 47972352 Hz ~=~ 48 MHz
  121 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  122 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
  123 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
  124 00000000         ;-------------------------------------------------------
                       --------
  125 00000000         ;UART0_BDL
  126 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
  127 00000000         ;UART0CLK is MCGFLLCLK
  128 00000000         ;MCGFLLCLK is 47972352 Hz ~=~ 48 MHz
  129 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  130 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
  131 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
  132 00000000         ;-------------------------------------------------------
                       --------
  133 00000000         ;UART0_C1
  134 00000000         ;0-->7:LOOPS=loops select (normal)
  135 00000000         ;0-->6:DOZEEN=doze enable (disabled)
  136 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
  137 00000000         ;0-->4:M=9- or 8-bit mode select 
  138 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
  139 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
  140 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
  141 00000000         ;0-->1:PE=parity enable (disabled)
  142 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
  143 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
  144 00000000         ;-------------------------------------------------------
                       --------
  145 00000000         ;UART0_C2
  146 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
  147 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)



ARM Macro Assembler    Page 5 Lab Exercise Nine Serial I/O Driver


  148 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
  149 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  150 00000000         ;1-->3:TE=transmitter enable (enabled)
  151 00000000         ;1-->2:RE=receiver enable (enabled)
  152 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  153 00000000         ;0-->0:SBK=send break (disabled, normal)
  154 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
  155 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C
2_T_R)
  156 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C
2_T_RI)
  157 00000000         ;-------------------------------------------------------
                       --------
  158 00000000         ;UART0_C3
  159 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  160 00000000         ;           10th data bit for transmitter (not used M10=
                       0)
  161 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  162 00000000         ;           10th data bit for receiver (not used M10=0)
  163 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  164 00000000         ;            (no effect LOOPS=0)
  165 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  166 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  167 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  168 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  169 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  170 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  171 00000000         ;-------------------------------------------------------
                       --------
  172 00000000         ;UART0_C4
  173 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled
                       )
  174 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled
                       )
  175 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  176 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  177 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  178 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  179 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  180 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  181 00000000         ;-------------------------------------------------------
                       --------
  182 00000000         ;UART0_C5
  183 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  184 00000000         ;  0-->  6:Reserved; read-only; always 0
  185 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)



ARM Macro Assembler    Page 6 Lab Exercise Nine Serial I/O Driver


  186 00000000         ;000-->4-2:Reserved; read-only; always 0
  187 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only
                       )
  188 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
                       
  189 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  190 00000000         ;-------------------------------------------------------
                       --------
  191 00000000         ;UART0_S1
  192 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  193 00000000         ;0-->6:TC=transmission complete flag; read-only
  194 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  195 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  196 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  197 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  198 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  199 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  204 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              (UART0_S1_IDLE_MASK :OR:      
                        UART0_S1_OR_MASK :OR:                              UAR
T0_S1_NF_MASK :OR:                              UART0_S1_FE_MASK :OR:        
                      UART0_S1_PF_MASK)
  205 00000000         ;-------------------------------------------------------
                       --------
  206 00000000         ;UART0_S2
  207 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  208 00000000         ;             write 1 to clear
  209 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  210 00000000         ;              write 1 to clear
  211 00000000         ;0-->5:(reserved); read-only; always 0
  212 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  213 00000000         ;0-->3:RWUID=receive wake-up idle detect
  214 00000000         ;0-->2:BRK13=break character generation length (10)
  215 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  216 00000000         ;0-->0:RAF=receiver active flag; read-only
  218 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              (UART0_S2_LBKDIF_MASK :OR: UART
0_S2_RXEDGIF_MASK)
  219 00000000         ;-------------------------------------------------------
                       --------
  220 00000000         ;*******************************************************
                       *********
  221 00000000         ;Program
  222 00000000         ;Linker requires Reset_Handler
  223 00000000                 AREA             MyCode,CODE,READONLY
  224 00000000                 ENTRY
  225 00000000                 EXPORT           Reset_Handler
  226 00000000                 IMPORT           Startup
  227 00000000         Reset_Handler
                               PROC             {}
  228 00000000         main
  229 00000000         ;-------------------------------------------------------



ARM Macro Assembler    Page 7 Lab Exercise Nine Serial I/O Driver


                       --------
  230 00000000         ;Mask interrupts
  231 00000000 B672            CPSID            I
  232 00000002         ;KL05 system startup with 48-MHz system clock
  233 00000002 F7FF FFFE       BL               Startup
  234 00000006         ;-------------------------------------------------------
                       --------
  235 00000006         ;>>>>> begin main program code <<<<<
  236 00000006 F7FF FFFE       BL               Init_UART0_IRQ
  237 0000000A B662            CPSIE            I
  238 0000000C 48FE            LDR              R0,=QBuffer
  239 0000000E 49FF            LDR              R1,=QRecord
  240 00000010 2204            MOVS             R2,#4
  241 00000012 F7FF FFFE       BL               InitQueue   ;initialize the que
                                                            ue
  242 00000016         loopHereInput
  243 00000016 F7FF FFFE       BL               CRLF        ;output CR and LF t
                                                            o terminal
  244 0000001A         ;output propmpt to terminal
  245 0000001A 48FD            LDR              R0,=PROMPT_QUEUE
  246 0000001C 2120            MOVS             R1,#PROMPT_QUEUE_LEN
  247 0000001E F7FF FFFE       BL               PutStringSB
  248 00000022 F7FF FFFE       BL               GetChar     ;get the typed char
                                                            
  249 00000026         ;checking if char is lowercase
  250 00000026 287A            CMP              R0,#'z'     ;check if ASCII is 
                                                            greater than 'z;
  251 00000028 D803            BHI              notLowerCase
  252 0000002A 2861            CMP              R0,#'a'
  253 0000002C D301            BLO              notLowerCase ;check if ASCII is
                                                             less than 'a'
  254 0000002E         ;Converting lowercase to uppercase
  255 0000002E 0007            MOVS             R7,R0       ;save a copy to r7
  256 00000030 3820            SUBS             R0,R0,#32   ;otherwise make upp
                                                            ercase subtract 32
  257 00000032         notLowerCase
  258 00000032 0007            MOVS             R7,R0       ;save a copy to r7
  259 00000034 2844            CMP              R0,#'D'
  260 00000036 D008            BEQ              DInstruction
  261 00000038 2845            CMP              R0,#'E'
  262 0000003A D022            BEQ              EInstruction
  263 0000003C 2848            CMP              R0,#'H'
  264 0000003E D046            BEQ              HInstruction
  265 00000040 2850            CMP              R0,#'P'
  266 00000042 D050            BEQ              PInstruction
  267 00000044 2853            CMP              R0,#'S'
  268 00000046 D06B            BEQ              SInstruction
  269 00000048         ;otherwise repeat regular 
  270 00000048 E7E5            B                loopHereInput
  271 0000004A         ;Special instructions
  272 0000004A         DInstruction
  273 0000004A 0038            MOVS             R0,R7       ;restore saved type
                                                            d char
  274 0000004C F7FF FFFE       BL               PutChar     ;output typed char 
                                                            to terminal
  275 00000050 F7FF FFFE       BL               CRLF        ;output CR and LF
  276 00000054 49ED            LDR              R1,=QRecord
  277 00000056 F7FF FFFE       BL               Dequeue
  278 0000005A D209            BCS              dequeueEmpty ;if carry set then



ARM Macro Assembler    Page 8 Lab Exercise Nine Serial I/O Driver


                                                             no char
  279 0000005C F7FF FFFE       BL               PutChar     ;output char from q
                                                            ueue to terminal
  280 00000060 203A            MOVS             R0,#':'     ;move ascii colon t
                                                            o r0
  281 00000062 F7FF FFFE       BL               PutChar     ;output colon
  282 00000066 48EB            LDR              R0,=SPACES8
  283 00000068 2108            MOVS             R1,#8
  284 0000006A F7FF FFFE       BL               PutStringSB ;print 8 spaces (" 
                                                                   ") to termin
                                                            al
  285 0000006E E067            B                step9       ;branch to step 9
  286 00000070         dequeueEmpty
  287 00000070 48E9            LDR              R0,=FAILURE_STR
  288 00000072 2107            MOVS             R1,#FAILURE_STR_LEN
  289 00000074 F7FF FFFE       BL               PutStringSB ;print "Failure:" t
                                                            o terminal
  290 00000078 48E8            LDR              R0,=SPACES2
  291 0000007A 2102            MOVS             R1,#2
  292 0000007C F7FF FFFE       BL               PutStringSB ;print 2 spaces (" 
                                                             ") to terminal
  293 00000080 E05E            B                step9       ;branch to step9
  294 00000082         EInstruction
  295 00000082 0038            MOVS             R0,R7       ;restore saved type
                                                            d char
  296 00000084 F7FF FFFE       BL               PutChar     ;output typed char 
                                                            to terminal
  297 00000088 F7FF FFFE       BL               CRLF        ;output CR and LF
  298 0000008C 48E4            LDR              R0,=ENQUEUE_STR
  299 0000008E 2114            MOVS             R1,#ENQUEUE_STR_LEN
  300 00000090 F7FF FFFE       BL               PutStringSB ;print enqueue prom
                                                            pt to terminal
  301 00000094         ;get and show typed char - followed by CRLF
  302 00000094 F7FF FFFE       BL               GetChar
  303 00000098 0002            MOVS             R2,R0       ;move char to R2 fo
                                                            r safekeeping 
  304 0000009A F7FF FFFE       BL               PutChar
  305 0000009E F7FF FFFE       BL               CRLF
  306 000000A2 49DA            LDR              R1,=QRecord ;R1 <- addr QRecord
                                                            
  307 000000A4 F7FF FFFE       BL               Enqueue     ;enque that char
  308 000000A8 D208            BCS              enqueueFail ;if c set then enqu
                                                            eue failed 
  309 000000AA 48DE            LDR              R0,=SUCCESS_STR
  310 000000AC 2107            MOVS             R1,#SUCCESS_STR_LEN
  311 000000AE F7FF FFFE       BL               PutStringSB ;print "Success:" t
                                                            o terminal
  312 000000B2 48DA            LDR              R0,=SPACES2
  313 000000B4 2102            MOVS             R1,#2
  314 000000B6 F7FF FFFE       BL               PutStringSB ;print 2 spaces (" 
                                                             ") to terminal
  315 000000BA E041            B                step9
  316 000000BC         enqueueFail
  317 000000BC 48D6            LDR              R0,=FAILURE_STR
  318 000000BE 2107            MOVS             R1,#FAILURE_STR_LEN
  319 000000C0 F7FF FFFE       BL               PutStringSB ;print "Failure:" t
                                                            o terminal
  320 000000C4 48D5            LDR              R0,=SPACES2
  321 000000C6 2102            MOVS             R1,#2



ARM Macro Assembler    Page 9 Lab Exercise Nine Serial I/O Driver


  322 000000C8 F7FF FFFE       BL               PutStringSB ;print 2 spaces (" 
                                                             ") to terminal
  323 000000CC E038            B                step9
  324 000000CE         HInstruction
  325 000000CE 0038            MOVS             R0,R7       ;restore saved type
                                                            d char
  326 000000D0 F7FF FFFE       BL               PutChar     ;output typed char 
                                                            to terminal
  327 000000D4 F7FF FFFE       BL               CRLF        ;output CR and LF
  328 000000D8 48D3            LDR              R0,=HELP_STR
  329 000000DA 2138            MOVS             R1,#HELP_STR_LEN
  330 000000DC F7FF FFFE       BL               PutStringSB ;print helpStr to t
                                                            erminal
  331 000000E0 F7FF FFFE       BL               CRLF        ;output CR and LF
  332 000000E4 E797            B                loopHereInput ;back to top
  333 000000E6         PInstruction
  334 000000E6 0038            MOVS             R0,R7       ;restore saved type
                                                            d char
  335 000000E8 F7FF FFFE       BL               PutChar     ;output typed char 
                                                            to terminal
  336 000000EC F7FF FFFE       BL               CRLF        ;output CR and LF
  337 000000F0 203E            MOVS             R0,#'>'     ;load '>'
  338 000000F2 F7FF FFFE       BL               PutChar     ;print '>'
  339 000000F6         ;print all actively queued characters in queue
  340 000000F6 4AC5            LDR              R2,=QRecord ;R2 <- addr QRecord
                                                            
  341 000000F8 6854            LDR              R4,[R2,#OUT_PTR] 
                                                            ;R4 <- addr OUT_PTR
                                                            
  342 000000FA 7C55            LDRB             R5,[R2,#NUM_ENQD] 
                                                            ;R5 <- NUM_ENQD
  343 000000FC 68D6            LDR              R6,[R2,#BUF_PAST] ;R6 <- addr B
                                                            UF_PAST
  344 000000FE 6897            LDR              R7,[R2,#BUF_STRT] ;R7 <- addr B
                                                            UF_STRT
  345 00000100         printyLoop
  346 00000100 2100            MOVS             R1,#0
  347 00000102 428D            CMP              R5,R1       ;if number enqueued
                                                             (or our equiv)
  348 00000104 D008            BEQ              noMorePrinty ;is zero, no more 
                                                            left
  349 00000106         ;if not zero then get + print the next
  350 00000106 7820            LDRB             R0,[R4,#0]  ;R0 <- contents add
                                                            r r4 (at OUT_PTR)
  351 00000108 F7FF FFFE       BL               PutChar     ;Print Ascii in R0 
                                                            to terminal   
  352 0000010C 1E6D            SUBS             R5,R5,#1    ;decrement NUM_ENQD
                                                             equiv by 1
  353 0000010E 1C64            ADDS             R4,R4,#1    ;increment OUT_PTR 
                                                            addr equiv by 1
  354 00000110 42B4            CMP              R4,R6
  355 00000112 D1F5            BNE              printyLoop  ;if OUT_PTR =! BUF_
                                                            PAST go again
  356 00000114 6894            LDR              R4,[R2,#BUF_STRT] ;if is past b
                                                            uf go to buf strt
  357 00000116 E7F3            B                printyLoop  ;try print again
  358 00000118         noMorePrinty
  359 00000118 203C            MOVS             R0,#'<'     ;load '<'
  360 0000011A F7FF FFFE       BL               PutChar     ;print '<'



ARM Macro Assembler    Page 10 Lab Exercise Nine Serial I/O Driver


  361 0000011E E77A            B                loopHereInput ;go get new input
                                                            
  362 00000120         SInstruction
  363 00000120 0038            MOVS             R0,R7       ;restore saved type
                                                            d char
  364 00000122 F7FF FFFE       BL               PutChar     ;output typed char 
                                                            to terminal
  365 00000126 F7FF FFFE       BL               CRLF        ;output CR and LF
  366 0000012A 2020            MOVS             R0,#' '     ;load ' '
  367 0000012C F7FF FFFE       BL               PutChar     ;print a single spa
                                                            ce to terminal
  368 00000130 48BE            LDR              R0,=STATUS_STR
  369 00000132 2106            MOVS             R1,#STATUS_STR_LEN
  370 00000134 F7FF FFFE       BL               PutStringSB ;print "Status:" to
                                                             terminal
  371 00000138 48B8            LDR              R0,=SPACES2
  372 0000013A 2102            MOVS             R1,#2
  373 0000013C F7FF FFFE       BL               PutStringSB ;print 2 spaces (" 
                                                             ") to terminal
  374 00000140         ;just continue to step 9
  375 00000140         step9
  376 00000140 48BB            LDR              R0,=IN_STR
  377 00000142 2104            MOVS             R1,#IN_STR_LEN
  378 00000144 F7FF FFFE       BL               PutStringSB ;print "In=0x" to t
                                                            erminal
  379 00000148         
  380 00000148 4AB0            LDR              R2,=QRecord ;R2 <- addr QRecord
                                                            
  381 0000014A 6813            LDR              R3,[R2,#IN_PTR] 
                                                            ;R3 <- addr IN_PTR
  382 0000014C 6854            LDR              R4,[R2,#OUT_PTR] 
                                                            ;R4 <- addr OUT_PTR
                                                            
  383 0000014E 7C55            LDRB             R5,[R2,#NUM_ENQD] ;R5 <- addr N
                                                            UM_ENQD
  384 00000150         ;LDRB R5,[R5,#0]  ;R5 <- NUM_ENQD
  385 00000150         
  386 00000150 0018            MOVS             R0,R3       ;copy IN_PTR to R0
  387 00000152 F7FF FFFE       BL               PutNumHex   ;Print  IN_PTR to t
                                                            erminal
  388 00000156         
  389 00000156 48B1            LDR              R0,=SPACES2
  390 00000158 2102            MOVS             R1,#2
  391 0000015A F7FF FFFE       BL               PutStringSB ;print 2 spaces (" 
                                                             ") to terminal
  392 0000015E         
  393 0000015E 48B5            LDR              R0,=OUT_STR
  394 00000160 2108            MOVS             R1,#OUT_STR_LEN
  395 00000162 F7FF FFFE       BL               PutStringSB ;print "Out=0x" to 
                                                            terminal
  396 00000166         
  397 00000166 0020            MOVS             R0,R4       ;move OUT_PTR to R0
                                                            
  398 00000168 F7FF FFFE       BL               PutNumHex   ;Print OUT_PTR to t
                                                            erminal
  399 0000016C         
  400 0000016C 48AB            LDR              R0,=SPACES2
  401 0000016E 2102            MOVS             R1,#2
  402 00000170 F7FF FFFE       BL               PutStringSB ;print 2 spaces (" 



ARM Macro Assembler    Page 11 Lab Exercise Nine Serial I/O Driver


                                                             ") to terminal
  403 00000174         
  404 00000174 48B0            LDR              R0,=NUM_STR
  405 00000176 2103            MOVS             R1,#NUM_STR_LEN
  406 00000178 F7FF FFFE       BL               PutStringSB ;print "Num=" to te
                                                            rminal
  407 0000017C         
  408 0000017C 0028            MOVS             R0,R5       ;move NUM_ENQD to R
                                                            0
  409 0000017E F7FF FFFE       BL               PutNumUB    ;Print NUM_ENQD to 
                                                            terminal
  410 00000182         
  411 00000182 E748            B                loopHereInput ;go to top of loo
                                                            ooooop
  412 00000184         
  413 00000184         ;>>>>>   end main program code <<<<<
  414 00000184         ;Stay here
  415 00000184 E7FE            B                .
  416 00000186                 ENDP
  417 00000186         ;>>>>> begin subroutine code <<<<<
  418 00000186         UART0_ISR
                               PROC             {R0-R14}
  419 00000186         ;*******************************************************
                       *********
  420 00000186         ;ISR that handles UART0 transmit and recieve interrupts.
                        You 
  421 00000186         ;must write the ISR so that no registers have changed va
                       lue after 
  422 00000186         ;return. (Note: the Cortex-M0+ automatically preserves R
                       0–R3, 
  423 00000186         ;R12, LR, PC, and PSR for ISRs.)
  424 00000186         ;*******************************************************
                       *********
  425 00000186 B672            CPSID            I           ;Mask interrupts
  426 00000188 B500            PUSH             {LR}
  427 0000018A         ;push any registers used except R0–R3, R12
  428 0000018A         ;interrupt source can be found in UART0_S1
  429 0000018A 4BB6            LDR              R3,=UART0_BASE
  430 0000018C 2180            MOVS             R1,#UART0_C2_TIE_MASK
  431 0000018E         ;  if (TxInteruptEnabled) then ;TIE = 1 in UART0_C2 
  432 0000018E 78DA            LDRB             R2,[R3,#UART0_C2_OFFSET]
  433 00000190 400A            ANDS             R2,R2,R1    ;if the bit was set
                                                             non zero value 
  434 00000192 2A00            CMP              R2,#0
  435 00000194 D00C            BEQ              if_TIE_0
  436 00000196         ;   if (TxInterrupt) then ;TDRE = 1 in UART0_S1 
  437 00000196 2180            MOVS             R1,#UART0_S1_TDRE_MASK
  438 00000198 791A            LDRB             R2,[R3,#UART0_S1_OFFSET]
  439 0000019A 400A            ANDS             R2,R2,R1    ;if the bit was set
                                                             non zero value 
  440 0000019C 2A00            CMP              R2,#0
  441 0000019E D007            BEQ              if_TIE_0
  442 000001A0         ;    Dequeue character from TxQueue 
  443 000001A0 49A6            LDR              R1,=TxQRecord
  444 000001A2 F7FF FFFE       BL               Dequeue
  445 000001A6 D201            BCS              unsuccessful_DQ
  446 000001A8         ;    if (dequeue successful) then 
  447 000001A8         ;     Write character to UART0_D ;Tx data reg. 
  448 000001A8 71D8            STRB             R0,[R3,#UART0_D_OFFSET]



ARM Macro Assembler    Page 12 Lab Exercise Nine Serial I/O Driver


  449 000001AA E001            B                if_TIE_0
  450 000001AC         ;    else
  451 000001AC         unsuccessful_DQ
  452 000001AC         ;     Disable TxInterrupt ;UART0_C2_T_RI 
  453 000001AC 202C            MOVS             R0,#UART0_C2_T_RI
  454 000001AE 70D8            STRB             R0,[R3,#UART0_C2_OFFSET]
  455 000001B0         if_TIE_0
  456 000001B0         ;  if (RxInterrupt) then ;RDRF = 1 in UART0_S1 
  457 000001B0 2120            MOVS             R1,#UART0_S1_RDRF_MASK
  458 000001B2 791A            LDRB             R2,[R3,#UART0_S1_OFFSET]
  459 000001B4 400A            ANDS             R2,R2,R1    ;if the bit was set
                                                             non zero value 
  460 000001B6 2A00            CMP              R2,#0
  461 000001B8 D003            BEQ              endGoodNaming
  462 000001BA         ;   Read character from UART0_D ;receive data register 
  463 000001BA 79D8            LDRB             R0,[R3,#UART0_D_OFFSET]
  464 000001BC         ;   Enqueue character in RxQueue 
  465 000001BC 49A0            LDR              R1,=RxQRecord
  466 000001BE F7FF FFFE       BL               Enqueue
  467 000001C2         ;   ;Character lost if RxQueue full 
  468 000001C2         endGoodNaming
  469 000001C2         ; Pop any registers pushed above 
  470 000001C2 B662            CPSIE            I           ; Unmask other inte
                                                            rrupts ;CPSIE I 
  471 000001C4 BD00            POP              {PC}
  472 000001C6                 ENDP
  473 000001C6         
  474 000001C6         Init_UART0_IRQ
                               PROC             {R0-R14}
  475 000001C6         ;*******************************************************
                       *********
  476 000001C6         ;Description:
  477 000001C6         ; This subroutine initializes the KL05 for interrupt -ba
                       sed serial
  478 000001C6         ; I/0 with UART0 using the format: 1 start bit, 8 data b
                       its, no 
  479 000001C6         ; parity, 1 stop bit at 9600 baud. same format and speed
                        as previous
  480 000001C6         ; but with interrupts instead of polling. Should configu
                       re UART0,
  481 000001C6         ; initialize the UART0 interrupt in NVIC, and should ini
                       tialize the 
  482 000001C6         ; receive and transmit queue management record structure
                       s (RxQRecord
  483 000001C6         ; and TxQRecord) for 80-character queue buffers (RxQBuff
                       er and 
  484 000001C6         ; TxQBuffer, respectively) using InitQueue from Lab Exer
                       cise Seven. 
  485 000001C6         ; (Suggestion: copy Init_UART0_Polling that has been use
                       d since 
  486 000001C6         ; Lab Exercise Five, and modify it to use interrupts ins
                       tead of 
  487 000001C6         ; polling, including changing UART0 initialization to su
                       pport 
  488 000001C6         ; UART0_ISR and calling InitQueue from Lab Exercise Seve
                       n to 
  489 000001C6         ; initialize the receive and transmit queue management r
                       ecord 
  490 000001C6         ; structures.)   



ARM Macro Assembler    Page 13 Lab Exercise Nine Serial I/O Driver


  491 000001C6         ;Input Parameter:
  492 000001C6         ; none
  493 000001C6         ;Output Parameter:
  494 000001C6         ; none
  495 000001C6         ;modified registers:
  496 000001C6         ; none
  497 000001C6         ;subroutines utilized:
  498 000001C6         ; 
  499 000001C6         ;*******************************************************
                       *********
  500 000001C6 B507            PUSH             {LR,R0-R2}
  501 000001C8         ;code copied from provided PDF
  502 000001C8         ;Select MCGFLLCLK as UART0 clock source
  503 000001C8 48A9            LDR              R0,=SIM_SOPT2
  504 000001CA 49AA            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  505 000001CC 6802            LDR              R2,[R0,#0]
  506 000001CE 438A            BICS             R2,R2,R1
  507 000001D0 49A9            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCL
K
  508 000001D2 430A            ORRS             R2,R2,R1
  509 000001D4 6002            STR              R2,[R0,#0]
  510 000001D6         ;Set UART0 for external connection
  511 000001D6 48A9            LDR              R0,=SIM_SOPT5
  512 000001D8 49A9            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK
_CLEAR
  513 000001DA 6802            LDR              R2,[R0,#0]
  514 000001DC 438A            BICS             R2,R2,R1
  515 000001DE 6002            STR              R2,[R0,#0]
  516 000001E0         ;Enable UART0 module clock
  517 000001E0 48A8            LDR              R0,=SIM_SCGC4
  518 000001E2 49A9            LDR              R1,=SIM_SCGC4_UART0_MASK
  519 000001E4 6802            LDR              R2,[R0,#0]
  520 000001E6 430A            ORRS             R2,R2,R1
  521 000001E8 6002            STR              R2,[R0,#0]
  522 000001EA         ;Enable PORT B module clock
  523 000001EA 48A8            LDR              R0,=SIM_SCGC5
  524 000001EC 49A6            LDR              R1,=SIM_SCGC5_PORTB_MASK
  525 000001EE 6802            LDR              R2,[R0,#0]
  526 000001F0 430A            ORRS             R2,R2,R1
  527 000001F2 6002            STR              R2,[R0,#0]
  528 000001F4         ;Select PORT B Pin 2 (D0) for UART0 RX (J8 Pin 01)
  529 000001F4 48A6            LDR              R0,=PORTB_PCR2
  530 000001F6 49A7            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  531 000001F8 6001            STR              R1,[R0,#0]
  532 000001FA         ; Select PORT B Pin 1 (D1) for UART0 TX (J8 Pin 02)
  533 000001FA 48A7            LDR              R0,=PORTB_PCR1
  534 000001FC 49A5            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  535 000001FE 6001            STR              R1,[R0,#0]
  536 00000200         ;Set UART0 IRQ priority 
  537 00000200 48A6            LDR              R0,=UART0_IPR
  538 00000202         ;LDR R1,=NVIC_IPR_UART0_MASK 
  539 00000202 4AA7            LDR              R2,=NVIC_IPR_UART0_PRI_3
  540 00000204 6803            LDR              R3,[R0,#0]
  541 00000206         ;BICS R3,R3,R1 
  542 00000206 4313            ORRS             R3,R3,R2
  543 00000208 6003            STR              R3,[R0,#0]
  544 0000020A         ;Clear any pending UART0 interrupts 
  545 0000020A 48A6            LDR              R0,=NVIC_ICPR
  546 0000020C 49A6            LDR              R1,=NVIC_ICPR_UART0_MASK



ARM Macro Assembler    Page 14 Lab Exercise Nine Serial I/O Driver


  547 0000020E 6001            STR              R1,[R0,#0]
  548 00000210         ;Unmask UART0 interrupts 
  549 00000210 48A6            LDR              R0,=NVIC_ISER
  550 00000212 49A5            LDR              R1,=NVIC_ISER_UART0_MASK
  551 00000214 6001            STR              R1,[R0,#0]
  552 00000216         ;Disable UART0 receiver and transmitter
  553 00000216 4893            LDR              R0,=UART0_BASE
  554 00000218 210C            MOVS             R1,#UART0_C2_T_R
  555 0000021A 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  556 0000021C 438A            BICS             R2,R2,R1
  557 0000021E 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  558 00000220         ;Set UART0 for 9600 baud, 8N1 protocol
  559 00000220 2101            MOVS             R1,#UART0_BDH_9600
  560 00000222 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  561 00000224 2138            MOVS             R1,#UART0_BDL_9600
  562 00000226 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  563 00000228 2100            MOVS             R1,#UART0_C1_8N1
  564 0000022A 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  565 0000022C 2100            MOVS             R1,#UART0_C3_NO_TXINV
  566 0000022E 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  567 00000230 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  568 00000232 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  569 00000234 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  570 00000236 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  571 00000238 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  572 0000023A 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  574 0000023C 21C0            MOVS             R1,       #UART0_S2_NO_RXINV_B
RK10_NO_LBKDETECT_CLEAR_FLAGS
  575 0000023E 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  576 00000240         ;Enable UART0 receiver and transmitter
  577 00000240 212C            MOVS             R1,#UART0_C2_T_RI ;edited this 
                                                            for IRQ
  578 00000242 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  579 00000244         ;end code from PDF
  580 00000244 487F            LDR              R0,=TxQBuffer
  581 00000246 497D            LDR              R1,=TxQRecord
  582 00000248 2250            MOVS             R2,#80
  583 0000024A F7FF FFFE       BL               InitQueue
  584 0000024E 487E            LDR              R0,=RxQBuffer
  585 00000250 497B            LDR              R1,=RxQRecord
  586 00000252 2250            MOVS             R2,#80
  587 00000254 F7FF FFFE       BL               InitQueue
  588 00000258         
  589 00000258 BD07            POP              {PC,R0-R2}
  590 0000025A                 ENDP
  591 0000025A         
  592 0000025A         PutChar PROC             {R0-R14}
  593 0000025A         ;*******************************************************
                       *********
  594 0000025A         ;Description:
  595 0000025A         ; Enqueues the character from R0 to the transmit queue
  596 0000025A         ;Input Parameter:
  597 0000025A         ; R0: character to enqueue (unsigned byte ASCII code)
  598 0000025A         ;Output Parameter:
  599 0000025A         ; none
  600 0000025A         ;modified registers:
  601 0000025A         ; nothing but PSR
  602 0000025A         ;*******************************************************
                       *********



ARM Macro Assembler    Page 15 Lab Exercise Nine Serial I/O Driver


  603 0000025A B503            PUSH             {LR,R0-R1}
  604 0000025C 4977            LDR              R1,=TxQRecord ;load addr TxQRec
                                                            ord
  605 0000025E         tryEnqueueLoop
  606 0000025E B672            CPSID            I
  607 00000260 F7FF FFFE       BL               Enqueue     ;put char in R0 int
                                                            o TxQBuffer
  608 00000264 B662            CPSIE            I
  609 00000266 D2FA            BCS              tryEnqueueLoop ;if c set (Enque
                                                            ue failed) try agai
                                                            n  
  610 00000268         ;enable transmit interrupt
  611 00000268 487E            LDR              R0,=UART0_BASE
  612 0000026A 21AC            MOVS             R1,#UART0_C2_TI_RI
  613 0000026C 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  614 0000026E BD03            POP              {PC,R0-R1}
  615 00000270                 ENDP
  616 00000270         
  617 00000270         GetChar PROC             {R1-R14}
  618 00000270         ;*******************************************************
                       *********
  619 00000270         ;Description:
  620 00000270         ; Dequeues a character from the recieve queue and return
                       s it in
  621 00000270         ; R0
  622 00000270         ;Input Parameter:
  623 00000270         ; none
  624 00000270         ;Output Parameter:
  625 00000270         ; R0: returned character (unsigned byte ASCII code)
  626 00000270         ;modified registers:
  627 00000270         ; Nothing but output parameter registers and PSR
  628 00000270         ;subroutines utilized:
  629 00000270         ; Dequeue
  630 00000270         ;*******************************************************
                       *********
  631 00000270         ;code from doc provided
  632 00000270 B502            PUSH             {LR,R1}
  633 00000272 4973            LDR              R1,=RxQRecord ;load addr RxQRec
                                                            ord
  634 00000274         tryDequeueLoop
  635 00000274 B672            CPSID            I
  636 00000276 F7FF FFFE       BL               Dequeue     ;R0<- char from RxQ
                                                            Buffer
  637 0000027A B662            CPSIE            I
  638 0000027C D2FA            BCS              tryDequeueLoop ;if c set (Deque
                                                            ue failed) try agai
                                                            n
  639 0000027E BD02            POP              {PC,R1}
  640 00000280                 ENDP
  641 00000280         
  642 00000280         CRLF    PROC             {R0-R14}
  643 00000280         ;*******************************************************
                       *********
  644 00000280         ;Description:
  645 00000280         ; This subroutine outputs a carriage return and a line-f
                       eed to
  646 00000280         ; the terminal screen.
  647 00000280         ;Input Parameter:
  648 00000280         ; none



ARM Macro Assembler    Page 16 Lab Exercise Nine Serial I/O Driver


  649 00000280         ;Output Parameter:
  650 00000280         ; none
  651 00000280         ;modified registers:
  652 00000280         ; none
  653 00000280         ;subroutines utilized:
  654 00000280         ; PutChar
  655 00000280         ;*******************************************************
                       *********
  656 00000280 B501            PUSH             {LR,R0}
  657 00000282 200D            MOVS             R0,#CR      ;load carriage retu
                                                            rn
  658 00000284 F7FF FFFE       BL               PutChar     ;print carriage ret
                                                            urn
  659 00000288 200A            MOVS             R0,#LF      ;load line feed
  660 0000028A F7FF FFFE       BL               PutChar     ;print line feed
  661 0000028E BD01            POP              {PC,R0}
  662 00000290 4770            BX               LR
  663 00000292                 ENDP
  664 00000292         
  665 00000292         JustClearC
                               PROC             {R0-R14}
  666 00000292         ;*******************************************************
                       *********
  667 00000292         ;Description:
  668 00000292         ; A subroutine with the sole purpose of setting the PSR 
                       
  669 00000292         ; bit "C" to 0
  670 00000292         ;Input Parameter:
  671 00000292         ; none
  672 00000292         ;Output Parameter:
  673 00000292         ; C: APSR bit set to 0, other PSR bits unchanged
  674 00000292         ;modified registers:
  675 00000292         ; no registers other than PSR bit C have changed values
  676 00000292         ; after return
  677 00000292         ;*******************************************************
                       *********
  678 00000292 B503            PUSH             {LR,R0-R1}
  679 00000294 F3EF 8000       MRS              R0,APSR
  680 00000298 2120            MOVS             R1,#0x20
  681 0000029A 0609            LSLS             R1,R1,#24
  682 0000029C 4388            BICS             R0,R0,R1
  683 0000029E F380 8800       MSR              APSR,R0
  684 000002A2 BD03            POP              {PC,R0-R1}
  685 000002A4 4770            BX               LR
  686 000002A6                 ENDP
  687 000002A6         
  688 000002A6         JustSetC
                               PROC             {R0-R14}
  689 000002A6         ;*******************************************************
                       *********
  690 000002A6         ;Description:
  691 000002A6         ; A subroutine with the sole purpose of setting the APSR
                        
  692 000002A6         ; bit "C" to 1
  693 000002A6         ;Input Parameter:
  694 000002A6         ; none
  695 000002A6         ;Output Parameter:
  696 000002A6         ; C: APSR bit set to 1, other PSR bits unchanged
  697 000002A6         ;modified registers:



ARM Macro Assembler    Page 17 Lab Exercise Nine Serial I/O Driver


  698 000002A6         ; no registers other than PSR bit C have changed values
  699 000002A6         ; after return
  700 000002A6         ;*******************************************************
                       *********
  701 000002A6 B503            PUSH             {LR,R0-R1}
  702 000002A8 F3EF 8000       MRS              R0,APSR
  703 000002AC 2120            MOVS             R1,#0x20
  704 000002AE 0609            LSLS             R1,R1,#24
  705 000002B0 4308            ORRS             R0,R0,R1
  706 000002B2 F380 8800       MSR              APSR,R0
  707 000002B6 BD03            POP              {PC,R0-R1}
  708 000002B8 4770            BX               LR
  709 000002BA                 ENDP
  710 000002BA         
  711 000002BA         Dequeue PROC             {R2-R14}
  712 000002BA         ;*******************************************************
                       *********
  713 000002BA         ;Description:
  714 000002BA         ; Attempts to get a character from the queue whose recor
                       d structure’s
  715 000002BA         ; address is in R1: if the queue is not empty, dequeues 
                       a single character
  716 000002BA         ; from the queue to R0, and returns with the PSR C bit c
                       leared, (i.e., 0),
  717 000002BA         ; to report dequeue success, otherwise, returns with the
                        PSR C bit set, 
  718 000002BA         ; (i.e., 1), to report dequeue failure.
  719 000002BA         ;Input Parameter: 
  720 000002BA         ; R1: queue record structure (unsigned word address)
  721 000002BA         ;Output Parameter/: 
  722 000002BA         ; R0: character dequeued (unsigned byte ASCII code)
  723 000002BA         ; R1: queue record structure (unsigned word address)
  724 000002BA         ; C: dequeue operation status: 0 success; 1 failure (PSR
                        bit flag)
  725 000002BA         ;modified registers:
  726 000002BA         ; no registers other than PSR (and any output parameters
                       ) have changed values
  727 000002BA         ; after return
  728 000002BA         ;subroutines utilized:
  729 000002BA         ; JustClearC
  730 000002BA         ; JustSetC
  731 000002BA         ;*******************************************************
                       *********
  732 000002BA B51C            PUSH             {LR,R2-R4}
  733 000002BC         ;first check if the queue is empty - if so indicate fail
                       ure + end
  734 000002BC 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;R2 <- number
                                                             of items in queue
  735 000002BE 2300            MOVS             R3,#0       ;R3 <- 0
  736 000002C0 429A            CMP              R2,R3
  737 000002C2 D00F            BEQ              queueEmpty  ;if num_enqued==0,e
                                                            nd and fail
  738 000002C4         ;otherwise dequeue into r0, update record, and indicate 
                       success
  739 000002C4 684C            LDR              R4,[R1,#OUT_PTR] ;load OUT_PTR 
                                                            addr into R4
  740 000002C6 7820            LDRB             R0,[R4,#0]  ;load byte value st
                                                            ored in addr in R4
  741 000002C8         ;update records and such



ARM Macro Assembler    Page 18 Lab Exercise Nine Serial I/O Driver


  742 000002C8 1E52            SUBS             R2,R2,#1    ;r2 <- r2-1
  743 000002CA 744A            STRB             R2,[R1,#NUM_ENQD] ;store decrem
                                                            ented number s
  744 000002CC         ;increment OUT_PTR (loop it to BUF_STRT if it hits BUF_P
                       AST)
  745 000002CC 684A            LDR              R2,[R1,#OUT_PTR]
  746 000002CE 1C52            ADDS             R2,R2,#1    ;increment OUT_PTR
  747 000002D0 68CB            LDR              R3,[R1,#BUF_PAST]
  748 000002D2 429A            CMP              R2,R3
  749 000002D4 DA01            BGE              passedBuffer ;branch if hit buf
                                                            _past
  750 000002D6 604A            STR              R2,[R1,#OUT_PTR] ;if no branch,
                                                             store incremented 
                                                            out ptr
  751 000002D8 E001            B                successDequeue ;branch to clear
                                                             c and end
  752 000002DA         passedBuffer
  753 000002DA 688B            LDR              R3,[R1,#BUF_STRT]
  754 000002DC 604B            STR              R3,[R1,#OUT_PTR] ;store new out
                                                             pointer as start o
                                                            f buf 
  755 000002DE         successDequeue                       ;clear c and end su
                                                            broutine
  756 000002DE F7FF FFFE       BL               JustClearC
  757 000002E2 E001            B                endDequeueHere
  758 000002E4         queueEmpty
  759 000002E4 F7FF FFFE       BL               JustSetC    ;run subroutine to 
                                                            set c and then end
  760 000002E8         endDequeueHere
  761 000002E8 BD1C            POP              {PC,R2-R4}
  762 000002EA 4770            BX               LR
  763 000002EC                 ENDP
  764 000002EC         
  765 000002EC         Enqueue PROC             {R2-R14}
  766 000002EC         ;*******************************************************
                       *********
  767 000002EC         ;Description:
  768 000002EC         ; Attempts to put a character in the queue whose queue r
                       ecord structure’s
  769 000002EC         ; address is in R1: if the queue is not full, enqueues t
                       he single character 
  770 000002EC         ; from R0 to the queue, and returns with the PSR C bit c
                       leared to report 
  771 000002EC         ; enqueue success, otherwise, returns with the PSR C bit
                        set to report 
  772 000002EC         ; enqueue failure.
  773 000002EC         ;Input Parameter: 
  774 000002EC         ; R0: character to enqueue (unsigned byte ASCII code)
  775 000002EC         ;~~ R1: queue record structure (unsigned word address)
  776 000002EC         ;Output Parameter: 
  777 000002EC         ; R1: queue record structure (unsigned word address)
  778 000002EC         ; C: enqueue operation status: 0 success; 1 failure (PSR
                        bit flag)
  779 000002EC         ;modified registers:
  780 000002EC         ; no registers other than PSR and any output parameters)
                        have changed values
  781 000002EC         ; after return
  782 000002EC         ;subroutines utilized:
  783 000002EC         ; JustClearC



ARM Macro Assembler    Page 19 Lab Exercise Nine Serial I/O Driver


  784 000002EC         ; JustSetC
  785 000002EC         ;*******************************************************
                       *********
  786 000002EC B57C            PUSH             {LR,R2-R6}
  787 000002EE 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;R2<-num enqu
                                                            eued (byte)
  788 000002F0 7C0B            LDRB             R3,[R1,#BUF_SIZE] ;R3<-max num 
                                                            Q items (byte)
  789 000002F2 429A            CMP              R2,R3       ;see if queueFull
  790 000002F4 DA11            BGE              queueFull   ;if queueFull go to
                                                             queueFull
  791 000002F6 680C            LDR              R4,[R1,#IN_PTR] ;R4<-Q IN_PTR
  792 000002F8 7020            STRB             R0,[R4,#0]  ;store char at IN_P
                                                            TR location 
  793 000002FA 1C52            ADDS             R2,R2,#1    ;increment num_enqu
                                                            ed
  794 000002FC 744A            STRB             R2,[R1,#NUM_ENQD] ;store update
                                                            d value
  795 000002FE 1C64            ADDS             R4,R4,#1    ;increment IN_PTR p
                                                            ast new item
  796 00000300 600C            STR              R4,[R1,#IN_PTR] ;store updated 
                                                            valueof inpointer
  797 00000302 68CD            LDR              R5,[R1,#BUF_PAST] ;R5<-BUF_PAST
                                                            
  798 00000304 42AC            CMP              R4,R5       ;Compare IN_PTR and
                                                             BUF_PAST
  799 00000306 D304            BLO              notExceeded ;if IN_PTR less tha
                                                            n BUF_PAST: notExce
                                                            eded
  800 00000308         ;if queue now full, set inptr to start of queue buffer
  801 00000308 688E            LDR              R6,[R1,#BUF_STRT] 
                                                            ;R6 <- start Q Buff
                                                            
  802 0000030A 600E            STR              R6,[R1,#IN_PTR] ;store updated 
                                                            inpointer
  803 0000030C F7FF FFFE       BL               JustClearC  ;indicate successfu
                                                            l enqueue
  804 00000310 E005            B                endImmediate
  805 00000312         notExceeded
  806 00000312 600C            STR              R4,[R1,#IN_PTR] ;store updated 
                                                            valueof inpointer
  807 00000314 F7FF FFFE       BL               JustClearC  ;indicate successfu
                                                            l enqueue
  808 00000318 E001            B                endImmediate
  809 0000031A         queueFull                            ;set c flag and end
                                                            
  810 0000031A F7FF FFFE       BL               JustSetC
  811 0000031E         endImmediate
  812 0000031E BD7C            POP              {PC,R2-R6}
  813 00000320 4770            BX               LR
  814 00000322                 ENDP
  815 00000322         
  816 00000322         InitQueue
                               PROC             {R0-R14}
  817 00000322         ;*******************************************************
                       *********
  818 00000322         ;Description:
  819 00000322         ; Initializes the queue record structure at the address 
                       in R1 for the empty



ARM Macro Assembler    Page 20 Lab Exercise Nine Serial I/O Driver


  820 00000322         ; queue buffer at the address in R0 of size given in R2,
                        (i.e., character 
  821 00000322         ; capacity).
  822 00000322         ;Input Parameter: 
  823 00000322         ; R0: queue buffer (unsigned word address)
  824 00000322         ; R1: queue record structure (unsigned word address)
  825 00000322         ; R2: queue capacity in bytes (unsigned byte value)
  826 00000322         ;Output Parameter: none
  827 00000322         ;modified registers:
  828 00000322         ; no registers other than PSR and any output parameters)
                        have changed values
  829 00000322         ; after return
  830 00000322         ;*******************************************************
                       *********
  831 00000322 B407            PUSH             {R0-R2}
  832 00000324 6008            STR              R0,[R1,#IN_PTR] ;store addr in 
                                                            ptr of Q in rec str
                                                            uct  
  833 00000326 6048            STR              R0,[R1,#OUT_PTR] ;store addr ou
                                                            t ptr of Q in rec s
                                                            truct 
  834 00000328 6088            STR              R0,[R1,#BUF_STRT] ;store addr Q
                                                             start in rec struc
                                                            t 
  835 0000032A 1880            ADDS             R0,R0,R2    ;R0 = R0 + Q capaci
                                                            ty
  836 0000032C 60C8            STR              R0,[R1,#BUF_PAST] ;str 1st addr
                                                             past Q buff end
  837 0000032E 740A            STRB             R2,[R1,#BUF_SIZE] ;store Q capa
                                                            city in rec struct
  838 00000330 2000            MOVS             R0,#0       ;R0 = 0
  839 00000332 7448            STRB             R0,[R1,#NUM_ENQD] ;store that n
                                                            othing enqueued so 
                                                            far
  840 00000334 BC07            POP              {R0-R2}
  841 00000336 4770            BX               LR
  842 00000338                 ENDP
  843 00000338         
  844 00000338         PutNumHex
                               PROC             {R0-R14}
  845 00000338         ;*******************************************************
                       *********
  846 00000338         ;Description:
  847 00000338         ; Prints to the terminal screen the text hexadecimal rep
                       resentation of the
  848 00000338         ; unsigned word value in R0. (For example, if R0 contain
                       s 0x000012FF, then 
  849 00000338         ; 000012FF should print on the terminal. Note: 12FF woul
                       d not be acceptable. 
  850 00000338         ; Do not use division to determine the hexadecimal digit
                        values—use bit masks 
  851 00000338         ; and shifts.)
  852 00000338         ;Input Parameter: 
  853 00000338         ; R0: number to print in hexadecimal (unsigned word valu
                       e)
  854 00000338         ;Output Parameter: none
  855 00000338         ;modified registers:
  856 00000338         ; no registers other than PSR and any output parameters)
                        have changed values



ARM Macro Assembler    Page 21 Lab Exercise Nine Serial I/O Driver


  857 00000338         ; after return
  858 00000338         ;subroutines utilized:
  859 00000338         ; PutChar
  860 00000338         ;*******************************************************
                       *********
  861 00000338 B5FF            PUSH             {LR,R0-R7}
  862 0000033A 0002            MOVS             R2,R0       ;copy unsigned word
                                                             value to r2
  863 0000033C 2308            MOVS             R3,#8       ;move 8 to r3 as a 
                                                            comparator
  864 0000033E 2400            MOVS             R4,#0       ;move 0 to r4 as a 
                                                            loop counter (i)
  865 00000340         ;need to put #0xFFFFFFF0 in r6 as clearing mask
  866 00000340 260F            MOVS             R6,#2_0000000000001111 ;will tr
                                                            y just like this
  867 00000342         
  868 00000342         
  869 00000342 2709            MOVS             R7,#9       ;comporator for asc
                                                            ii
  870 00000344         convertLoopHex
  871 00000344 2504            MOVS             R5,#4       ;move 4 to R5 as a 
                                                            multiplication cons
                                                            t.
  872 00000346 0010            MOVS             R0,R2       ;restore original h
                                                            ex value
  873 00000348 4365            MULS             R5,R4,R5    ;R5<-4*1
  874 0000034A 40E8            LSRS             R0,R0,R5    ;shift right 4*i bi
                                                            ts(=1 nibble= 1 hex
                                                             char)
  875 0000034C         ;and pad with zeros on the left
  876 0000034C 4030            ANDS             R0,R0,R6    ;clear all but LSB 
                                                            of R0
  877 0000034E 42B8            CMP              R0,R7       ;compare single hex
                                                             digit with 
  878 00000350 DD01            BLE              hexLessThan9 ;if 9 or less just
                                                             add 0x30
  879 00000352 2137            MOVS             R1,#0x37    ;if  >9, add 0x32 (
                                                            idk why not 0x40) 
  880 00000354 E000            B                nowConvert
  881 00000356         hexLessThan9
  882 00000356 2130            MOVS             R1,#0x30    ;ascii conversion m
                                                            ask
  883 00000358         nowConvert
  884 00000358 1840            ADDS             R0,R0,R1    ;convert hex charac
                                                            ter to ascii
  885 0000035A B401            PUSH             {R0}        ;push R0 to print l
                                                            ater in reverse ord
                                                            er
  886 0000035C 1C64            ADDS             R4,R4,#1    ;increment i
  887 0000035E 42A3            CMP              R3,R4
  888 00000360 D000            BEQ              endConvertHex ;once counter equ
                                                            al to 8 its done   
                                                            
  889 00000362 E7EF            B                convertLoopHex
  890 00000364         endConvertHex
  891 00000364         ;pop 8 times from the stack and print using putchar (LIF
                       O)
  892 00000364 2400            MOVS             R4,#0       ;new loop counter n
                                                             at 0



ARM Macro Assembler    Page 22 Lab Exercise Nine Serial I/O Driver


  893 00000366         LIFOPrintLoop
  894 00000366 42A3            CMP              R3,R4       ;compare n to 8
  895 00000368 D004            BEQ              finishedLIFOPrint ;when equal s
                                                            top print looping
  896 0000036A BC01            POP              {R0}
  897 0000036C F7FF FFFE       BL               PutChar
  898 00000370 1C64            ADDS             R4,R4,#1    ;increment n
  899 00000372 E7F8            B                LIFOPrintLoop
  900 00000374         finishedLIFOPrint
  901 00000374 BDFF            POP              {PC,R0-R7}
  902 00000376 4770            BX               LR
  903 00000378                 ENDP
  904 00000378         
  905 00000378         PutNumUB
                               PROC             {R0-R14}
  906 00000378         ;*******************************************************
                       *********
  907 00000378         ;Description:
  908 00000378         ; Prints to the terminal screen the text decimal represe
                       ntation of the
  909 00000378         ; unsigned byte value in R0. (For example, if R0 contain
                       s 0x003021101, 
  910 00000378         ; then 1 should print on the terminal. Note: 001 would a
                       lso be acceptable, 
  911 00000378         ; as the text decimal representation of 0x01.) (Hint: us
                       e a mask to preserve 
  912 00000378         ; only the least byte of the word in R0, and call your P
                       utNumU subroutine
  913 00000378         ; from Lab Exercise Six.)
  914 00000378         ;Input Parameter: 
  915 00000378         ; R0: number to print in decimal (unsigned byte value)
  916 00000378         ;Output Parameter: none
  917 00000378         ;modified registers:
  918 00000378         ; no registers other than PSR and any output parameters)
                        have changed values
  919 00000378         ; after return
  920 00000378         ;subroutines utilized:
  921 00000378         ; PutNumU
  922 00000378         ;*******************************************************
                       *********
  923 00000378 B503            PUSH             {LR,R0-R1}
  924 0000037A 210F            MOVS             R1,#2_00001111 
                                                            ;put mask into r1-1
                                                            
  925 0000037C B249            SXTB             R1,R1       ;sign extend to fin
                                                            ish
  926 0000037E 4008            ANDS             R0,R0,R1    ;AND with the mask 
                                                            to preserve only LS
                                                            B
  927 00000380 F7FF FFFE       BL               PutNumU     ;use PutNumU to pri
                                                            nt the byte
  928 00000384 BD03            POP              {PC,R0-R1}
  929 00000386 4770            BX               LR
  930 00000388                 ENDP
  931 00000388         
  932 00000388         PutNumU PROC             {R0-R14}
  933 00000388         ;*******************************************************
                       *********
  934 00000388         ;Displays text decimal representation of value to termin



ARM Macro Assembler    Page 23 Lab Exercise Nine Serial I/O Driver


                       al screen
  935 00000388         ;This subroutine displays the text decimal representatio
                       n to the
  936 00000388         ;terminal screen of the unsigned word value in R0, using
                        PutChar 
  937 00000388         ;to output each decimal digit character. (For example, i
                       f R0 
  938 00000388         ;contains 0x00000100, then 256 should be output 00000002
                       56 would 
  939 00000388         ;also be acceptable.) (hint use divU)
  940 00000388         ;Input Parameters: 
  941 00000388         ;R0: number for output to terminal(unsigned word value)
  942 00000388         ;Output Parameter:
  943 00000388         ; none
  944 00000388         ;no registers but PSR changed after return
  945 00000388         ;Subroutines used:
  946 00000388         ; DIVU
  947 00000388         ; PutChar
  948 00000388         ;*******************************************************
                       *********
  949 00000388 B53F            PUSH             {LR,R0-R5}
  950 0000038A 0002            MOVS             R2,R0       ;backup word value 
                                                            in R2
  951 0000038C 230A            MOVS             R3,#10      ;store 10 to be the
                                                             denominator
  952 0000038E 2400            MOVS             R4,#0       ;store counter in R
                                                            4
  953 00000390 0011            MOVS             R1,R2       ;move word value to
                                                             numerator
  954 00000392         convertLoop
  955 00000392 0018            MOVS             R0,R3       ;move 10 to be the 
                                                            denominator
  956 00000394         
  957 00000394 F7FF FFFE       BL               DIVU        ;use DIVU    
  958 00000398 B402            PUSH             {R1}        ;store the remainde
                                                            r in the stack
  959 0000039A 1C64            ADDS             R4,R4,#1    ;increment counter
  960 0000039C 0001            MOVS             R1,R0       ;move the quotient 
                                                            so that it will be 
                                                            the ~~~~
  961 0000039E         ;numerator next time around
  962 0000039E 2800            CMP              R0,#0       ;check if quotient 
                                                            is 0, if so done
  963 000003A0 D1F7            BNE              convertLoop ;if quotient not eq
                                                            ual 0 go again
  964 000003A2         popLoop
  965 000003A2 BC01            POP              {R0}        ;pop individual res
                                                            ult to the register
                                                             r0
  966 000003A4 2530            MOVS             R5,#0x30    ;move hex 30 into t
                                                            he register
  967 000003A6 1940            ADDS             R0,R0,R5    ;add to r0 to make 
                                                            ascii from dec
  968 000003A8 F7FF FFFE       BL               PutChar     ;use putchar to out
                                                            put to the terminal
                                                              
  969 000003AC 1E64            SUBS             R4,R4,#1    ;decrement counter
  970 000003AE 2C00            CMP              R4,#0       ;see if counter is 
                                                            back to 0



ARM Macro Assembler    Page 24 Lab Exercise Nine Serial I/O Driver


  971 000003B0 DCF7            BGT              popLoop     ;if counter still p
                                                            ositive loop again 
                                                             
  972 000003B2 BD3F            POP              {PC,R0-R5}  ;restore registers
  973 000003B4 4770            BX               LR          ;branch back to whe
                                                            re putNumU was call
                                                            ed
  974 000003B6                 ENDP
  975 000003B6         
  976 000003B6         DIVU    PROC             {R2-R14}
  977 000003B6         ;*******************************************************
                       *********
  978 000003B6         ;Subroutine from lab 4 created to perform integer divisi
                       on
  979 000003B6         ;Input: Parameters:
  980 000003B6         ; R0: divisor (denominator)
  981 000003B6         ; R1: dividend (numerator)
  982 000003B6         ;Output Parameters
  983 000003B6         ; R0: quotient
  984 000003B6         ; R1: remainder
  985 000003B6         ; C: APSR flag: 0 for valid result; 1 for invalid result
                       
  986 000003B6         ;*******************************************************
                       *********
  987 000003B6 2800            CMP              R0,#0       ;check if divisor (
                                                            denominator) is alr
                                                            eady zero
  988 000003B8 D015            BEQ              div0        ;if so branch to di
                                                            v0 to set c flag
  989 000003BA B40C            PUSH             {R2,R3}     ;store R2 and R3 on
                                                             the stack
  990 000003BC 2900            CMP              R1,#0       ;check if dividend(
                                                            numerator) is zero
  991 000003BE D007            BEQ              zerodiv     ;if so set outputs 
                                                            to 0 and clear C fl
                                                            ag
  992 000003C0         
  993 000003C0         ;actual division part
  994 000003C0 2200            MOVS             R2,#0       ;quotient =0 (R2 wi
                                                            ll be quotient whil
                                                            e computing)
  995 000003C2         divuloop
  996 000003C2 4281            CMP              R1,R0       ;while dividend>=di
                                                            visor
  997 000003C4 D302            BLO              divuFinish
  998 000003C6 1A09            SUBS             R1,R1,R0    ;dividend=dividend-
                                                            divisor
  999 000003C8 1C52            ADDS             R2,R2,#1    ;quotient=quotient+
                                                            1
 1000 000003CA E7FA            B                divuloop
 1001 000003CC         divuFinish
 1002 000003CC 0010            MOVS             R0,R2       ;R0 =quotient = p
 1003 000003CE         ;R1 = remainder = dividend = q
 1004 000003CE E001            B                clearC      ;branch and clearC 
                                                            then endit
 1005 000003D0         zerodiv                              ;if dividing zero b
                                                            y anything the resu
                                                            lt is 0 rem 0
 1006 000003D0 2000            MOVS             R0,#0



ARM Macro Assembler    Page 25 Lab Exercise Nine Serial I/O Driver


 1007 000003D2 2100            MOVS             R1,#0
 1008 000003D4         clearC
 1009 000003D4 F3EF 8200       MRS              R2,APSR
 1010 000003D8 2320            MOVS             R3,#0x20
 1011 000003DA 061B            LSLS             R3,R3,#24
 1012 000003DC 439A            BICS             R2,R2,R3
 1013 000003DE F382 8800       MSR              APSR,R2
 1014 000003E2 BC0C            POP              {R2,R3}     ;restore R2 and R3 
                                                            from stack
 1015 000003E4 E001            B                endit
 1016 000003E6         div0                                 ;time to set the C 
                                                            flag and leave all 
                                                            else unchanged
 1017 000003E6 F7FF FFFE       BL               JustSetC
 1018 000003EA         endit
 1019 000003EA 4770            BX               LR
 1020 000003EC                 ENDP
 1021 000003EC         
 1022 000003EC         PutStringSB
                               PROC             {R0-R14}
 1023 000003EC         ;*******************************************************
                       *********
 1024 000003EC         ;Displays string from memory to terminal screen
 1025 000003EC         ;Preventing overrun of the buffer capacity specified in 
                       R1, 
 1026 000003EC         ;this subroutine displays a null-terminated string to th
                       e terminal 
 1027 000003EC         ;screen from memory starting at the address in R0. It us
                       es PutChar 
 1028 000003EC         ;to display characters from the string and leaves the te
                       rminal 
 1029 000003EC         ;screen cursor positioned after the last character of th
                       e string.
 1030 000003EC         ;Input Parameters: 
 1031 000003EC         ; R0: string buffer in memory for output to simulated ou
                       tput stream 
 1032 000003EC         ; (unsigned word address)
 1033 000003EC         ; R1: bytes in string buffer where R0 points (unsigned w
                       ord value)
 1034 000003EC         ;Output Parameter:
 1035 000003EC         ; none
 1036 000003EC         ;no registers but PSR changed after return
 1037 000003EC         ;Subroutines used:
 1038 000003EC         ; PutChar
 1039 000003EC         ;*******************************************************
                       *********
 1040 000003EC         
 1041 000003EC B50F            PUSH             {LR,R0-R3}
 1042 000003EE 0002            MOVS             R2,R0       ;copy starting addr
                                                            ess of string
 1043 000003F0 2300            MOVS             R3,#0       ;initialize counter
                                                            
 1044 000003F2         printLoop
 1045 000003F2 5CD0            LDRB             R0,[R2,R3]  ;configure input to
                                                             PutChar correctly 
                                                            with
 1046 000003F4         ;offset
 1047 000003F4 2800            CMP              R0,#NULL    ;compare to see if 
                                                            null character an



ARM Macro Assembler    Page 26 Lab Exercise Nine Serial I/O Driver


 1048 000003F6 D004            BEQ              stopPrint   ;if so terminate
 1049 000003F8         
 1050 000003F8 F7FF FFFE       BL               PutChar     ;use putchar to out
                                                            put char R0 to term
                                                            inal   
 1051 000003FC         
 1052 000003FC 1C5B            ADDS             R3,R3,#1    ;increment counter
 1053 000003FE 428B            CMP              R3,R1
 1054 00000400 DDF7            BLE              printLoop   ;if the counter is 
                                                            less than or equal 
                                                            to the 
 1055 00000402         stopPrint                            ;num bytes in the s
                                                            tring branch and ge
                                                            t next
 1056 00000402 BD0F            POP              {PC,R0-R3}  ;otherwise restore 
                                                            registers and exit
 1057 00000404 4770            BX               LR
 1058 00000406                 ENDP
 1059 00000406         ;>>>>>   end subroutine code <<<<<
 1060 00000406 00 00           ALIGN
 1061 00000408         ;*******************************************************
                       *********
 1062 00000408         ;Vector Table Mapped to Address 0 at Reset
 1063 00000408         ;Linker requires __Vectors to be exported
 1064 00000408 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              4006A000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 
              40048034 
              00000400 
              40048038 
              4004A008 



ARM Macro Assembler    Page 27 Lab Exercise Nine Serial I/O Driver


              01000200 
              4004A004 
              E000E40C 
              000000C0 
              E000E280 
              00001000 
              E000E100 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000         AREA             RESET, DATA, READONLY
 1065 00000000                 EXPORT           __Vectors
 1066 00000000                 EXPORT           __Vectors_End
 1067 00000000                 EXPORT           __Vectors_Size
 1068 00000000                 IMPORT           __initial_sp
 1069 00000000                 IMPORT           Dummy_Handler
 1070 00000000                 IMPORT           HardFault_Handler
 1071 00000000         __Vectors
 1072 00000000         ;ARM core vectors
 1073 00000000 00000000        DCD              __initial_sp ;00:end of stack
 1074 00000004 00000000        DCD              Reset_Handler ;01:reset vector
 1075 00000008 00000000        DCD              Dummy_Handler ;02:NMI
 1076 0000000C 00000000        DCD              HardFault_Handler 
                                                            ;03:hard fault
 1077 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
 1078 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
 1079 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
 1080 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
 1081 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
 1082 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
 1083 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
 1084 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)
 1085 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
 1086 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
 1087 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (Penda
                                                            bleSrvReq)
 1088 0000003C         ;   pendable request 
 1089 0000003C         ;   for system service)
 1090 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)
 1091 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             transfer 
 1092 00000044         ;   complete/error
 1093 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             transfer
 1094 00000048         ;   complete/error
 1095 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             transfer
 1096 0000004C         ;   complete/error
 1097 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             transfer
 1098 00000050         ;   complete/error
 1099 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
 1100 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command 
                                                            complete/
 1101 00000058         ;   read collision



ARM Macro Assembler    Page 28 Lab Exercise Nine Serial I/O Driver


 1102 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
 1103 0000005C         ;   low-voltage warning
 1104 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
 1105 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1106 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
 1107 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
 1108 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
 1109 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; 
                                                            error)
 1110 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
 1111 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
 1112 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1113 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1114 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1115 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1116 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
 1117 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1118 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
 1119 00000098 00000000        DCD              Dummy_Handler ;38:PIT
 1120 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
 1121 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)
 1122 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1123 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1124 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1125 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1126 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
 1127 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
 1128 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
 1129 000000C0         __Vectors_End
 1130 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1131 000000C0                 ALIGN
 1132 000000C0         ;*******************************************************
                       *********
 1133 000000C0         ;Constants
 1134 000000C0                 AREA             MyConst,DATA,READONLY
 1135 00000000         ;>>>>> begin constants here <<<<<
 1136 00000000         
 1137 00000000         ;following from Lab 7
 1138 00000000 54 79 70 
              65 20 61 
              20 71 75 
              65 75 65 
              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 44 2C 
              45 2C 48 
              2C 50 2C 
              53 29 3A PROMPT_QUEUE
                               DCB              "Type a queue command (D,E,H,P,
S):"
 1139 00000021 46 61 69 
              6C 75 72 
              65 3A    FAILURE_STR



ARM Macro Assembler    Page 29 Lab Exercise Nine Serial I/O Driver


                               DCB              "Failure:"
 1140 00000029 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A ENQUEUE_STR
                               DCB              "Character to enqueue:"
 1141 0000003E 53 75 63 
              63 65 73 
              73 3A    SUCCESS_STR
                               DCB              "Success:"
 1142 00000046 53 74 61 
              74 75 73 
              3A       STATUS_STR
                               DCB              "Status:"
 1143 0000004D 49 6E 3D 
              30 78    IN_STR  DCB              "In=0x"
 1144 00000052 20 20 20 
              4F 75 74 
              3D 30 78 OUT_STR DCB              "   Out=0x"
 1145 0000005B 4E 75 6D 
              3D       NUM_STR DCB              "Num="
 1146 0000005F         
 1148 0000005F 44 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 45 20 
              28 65 6E 
              71 75 65 
              75 65 29 
              2C 20 48 
              20 28 68 
              65 6C 70 
              29 2C 20 
              50 20 28 
              70 72 69 
              6E 74 29 
              2C 20 53 
              20 28 73 
              74 61 74 
              75 73 29 HELP_STR
                               DCB              "D (dequeue), E (enqueue), H (h
elp), P (print), S (status)"
 1149 00000098 20 20   SPACES2 DCB              "  "
 1150 0000009A 20 20 20 
              20 20 20 
              20 20    SPACES8 DCB              "        "
 1151 000000A2         ;>>>>>   end constants here <<<<<
 1152 000000A2 00 00           ALIGN
 1153 000000A4         ;*******************************************************
                       *********
 1154 000000A4         ;Variables
 1155 000000A4                 AREA             MyData,DATA,READWRITE
 1156 00000000         ;>>>>> begin variables here <<<<<
 1157 00000000 00 00 00 
              00 00 00 



ARM Macro Assembler    Page 30 Lab Exercise Nine Serial I/O Driver


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQRecord
                               SPACE            18          ;record structure f
                                                            or TxQBuffer
 1158 00000012 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    TxQBuffer
                               SPACE            80          ;80 character trans
                                                            mit queue buffer
 1159 00000062 00 00           ALIGN
 1160 00000064 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQRecord
                               SPACE            18          ;record structure f
                                                            or RxQBuffer
 1161 00000076 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 31 Lab Exercise Nine Serial I/O Driver


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxQBuffer
                               SPACE            80          ;80 character recie
                                                            ve queue buffer
 1162 000000C6 00 00           ALIGN
 1163 000000C8         ;following from Lab 7
 1164 000000C8 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QRecord SPACE            Q_REC_SZ    ;allocate 18 bytes 
                                                            to variable QRecord
                                                            
 1165 000000DA 00 00 00 
              00       QBuffer SPACE            Q_BUF_SZ    ;allocate 4  bytes 
                                                            to variable QBuffer
                                                            
 1166 000000DE         ;>>>>>   end variables here <<<<<
 1167 000000DE 00 00           ALIGN
 1168 000000E0                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\objects\exercise09.d -o.\objects\exercise09.o -IC:\Users\Atticus\AppDa
ta\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Include -IC:\Keil_v5\ARM
\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSION SETA 
531" --predefine="MKL05Z32xxx4 SETA 1" --list=.\listings\exercise09.lst Exercis
e09.s
