


ARM Macro Assembler    Page 1 CMPE 250 Exercise 6


    1 00000000                 TTL              CMPE 250 Exercise 6
    2 00000000         ;****************************************************************
    3 00000000         ;Polled Serial I/O
    4 00000000         ;Name:  <Atticus Russell>
    5 00000000         ;Date:  <3/04/2021>
    6 00000000         ;Class:  CMPE-250
    7 00000000         ;Section:  <Section 01L1, Thursday, 2:00-3:55>
    8 00000000         ;---------------------------------------------------------------
    9 00000000         ;Keil Template for KL05
   10 00000000         ;R. W. Melton
   11 00000000         ;September 13, 2020
   12 00000000         ;****************************************************************
   13 00000000         ;Assembler directives
   14 00000000                 THUMB
   16 00000000         ;****************************************************************
   17 00000000         ;Include files
   18 00000000                 GET              MKL05Z4.s   ;Included by start.s
   20 00000000         ;****************************************************************
   21 00000000         ;EQUates (copied from Useful equates mycourses)
   22 00000000         ;Characters
   23 00000000 0000000D 
                       CR      EQU              0x0D        ;moves cursor beginning line
   24 00000000 0000000A 
                       LF      EQU              0x0A        ;adds new line
   25 00000000 00000000 
                       NULL    EQU              0x00
   26 00000000         
   27 00000000 0000004F 
                       MAX_STRING
                               EQU              79          ;the maximum number of string characters, 
   28 00000000         ; including the null termination character
   29 00000000 00000007 
                       LEN_LENGTH
                               EQU              7           ;the num characters in "Length:"
   30 00000000         ;---------------------------------------------------------------
   31 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   32 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   33 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   34 00000000         ;---------------------------------------------------------------
   35 00000000         ;Port B
   37 00000000 01000200 
                       PORT_PCR_SET_PTB2_UART0_RX



ARM Macro Assembler    Page 2 CMPE 250 Exercise 6


                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   39 00000000 01000200 
                       PORT_PCR_SET_PTB1_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   40 00000000         ;---------------------------------------------------------------
   41 00000000         ;SIM_SCGC4
   42 00000000         ;1->10:UART0 clock gate control (enabled)
   43 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   44 00000000         ;---------------------------------------------------------------
   45 00000000         ;SIM_SCGC5
   46 00000000         ;1->10:Port B clock gate control (enabled)
   47 00000000         ;Use provided SIM_SCGC5_PORTB_MASK
   48 00000000         ;---------------------------------------------------------------
   49 00000000         ;SIM_SOPT2
   50 00000000         ;01=27-26:UART0SRC=UART0 clock source select (MCGFLLCLK)
   51 00000000         ;---------------------------------------------------------------
   53 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGFLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   54 00000000         ;---------------------------------------------------------------
   55 00000000         ;SIM_SOPT5
   56 00000000         ; 0->   16:UART0 open drain enable (disabled)
   57 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   58 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   62 00000000 00010005 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   63 00000000         ;---------------------------------------------------------------
   64 00000000         ;UART0_BDH
   65 00000000         ;    0->  7:LIN break detect IE (disabled)
   66 00000000         ;    0->  6:RxD input active edge IE (disabled)
   67 00000000         ;    0->  5:Stop bit number select (1)
   68 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   69 00000000         ;UART0CLK is MCGFLLCLK
   70 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   71 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   72 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   73 00000000 00000001 
                       UART0_BDH_9600



ARM Macro Assembler    Page 3 CMPE 250 Exercise 6


                               EQU              0x01
   74 00000000         ;---------------------------------------------------------------
   75 00000000         ;UART0_BDL
   76 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   77 00000000         ;UART0CLK is MCGFLLCLK
   78 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   79 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   80 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   81 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   82 00000000         ;---------------------------------------------------------------
   83 00000000         ;UART0_C1
   84 00000000         ;0-->7:LOOPS=loops select (normal)
   85 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   86 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
   87 00000000         ;0-->4:M=9- or 8-bit mode select 
   88 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   89 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   90 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
   91 00000000         ;0-->1:PE=parity enable (disabled)
   92 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   93 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   94 00000000         ;---------------------------------------------------------------
   95 00000000         ;UART0_C2
   96 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   97 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   98 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   99 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  100 00000000         ;1-->3:TE=transmitter enable (enabled)
  101 00000000         ;1-->2:RE=receiver enable (enabled)
  102 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  103 00000000         ;0-->0:SBK=send break (disabled, normal)
  104 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  105 00000000         ;---------------------------------------------------------------
  106 00000000         ;UART0_C3
  107 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  108 00000000         ;           10th data bit for transmitter (not used M10=0)



ARM Macro Assembler    Page 4 CMPE 250 Exercise 6


  109 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  110 00000000         ;           10th data bit for receiver (not used M10=0)
  111 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  112 00000000         ;            (no effect LOOPS=0)
  113 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  114 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  115 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  116 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  117 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  118 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  119 00000000         ;---------------------------------------------------------------
  120 00000000         ;UART0_C4
  121 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  122 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  123 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  124 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  125 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  126 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  127 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  128 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  129 00000000         ;---------------------------------------------------------------
  130 00000000         ;UART0_C5
  131 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  132 00000000         ;  0-->  6:Reserved; read-only; always 0
  133 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  134 00000000         ;000-->4-2:Reserved; read-only; always 0
  135 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  136 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  137 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  138 00000000         ;---------------------------------------------------------------
  139 00000000         ;UART0_S1
  140 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  141 00000000         ;0-->6:TC=transmission complete flag; read-only
  142 00000000         ;0-->5:RDRF=receive data register full flag; read-only



ARM Macro Assembler    Page 5 CMPE 250 Exercise 6


  143 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  144 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  145 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  146 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  147 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  152 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              (UART0_S1_IDLE_MASK :OR:                              UART0_S1_OR_MASK 
:OR:                              UART0_S1_NF_MASK :OR:                              UART0_S1_FE_MASK :OR:           
                   UART0_S1_PF_MASK)
  153 00000000         ;---------------------------------------------------------------
  154 00000000         ;UART0_S2
  155 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  156 00000000         ;             write 1 to clear
  157 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  158 00000000         ;              write 1 to clear
  159 00000000         ;0-->5:(reserved); read-only; always 0
  160 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  161 00000000         ;0-->3:RWUID=receive wake-up idle detect
  162 00000000         ;0-->2:BRK13=break character generation length (10)
  163 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  164 00000000         ;0-->0:RAF=receiver active flag; read-only
  166 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              (UART0_S2_LBKDIF_MASK :OR: UART0_S2_RXEDGIF_MASK)
  167 00000000         ;---------------------------------------------------------------
  168 00000000         ;****************************************************************
  169 00000000         ;Program
  170 00000000         ;Linker requires Reset_Handler
  171 00000000                 AREA             MyCode,CODE,READONLY
  172 00000000                 ENTRY
  173 00000000                 EXPORT           Reset_Handler
  174 00000000                 IMPORT           LengthStringSB ;from ex6_lib
  175 00000000                 IMPORT           Startup
  176 00000000                 EXPORT           PutChar
  177 00000000         Reset_Handler
                               PROC             {}
  178 00000000         main
  179 00000000         ;---------------------------------------------------------------
  180 00000000         ;Mask interrupts
  181 00000000 B672            CPSID            I
  182 00000002         ;KL05 system startup with 48-MHz system clock



ARM Macro Assembler    Page 6 CMPE 250 Exercise 6


  183 00000002 F7FF FFFE       BL               Startup
  184 00000006         ;---------------------------------------------------------------
  185 00000006         ;>>>>> begin main program code <<<<<
  186 00000006 F7FF FFFE       BL               Init_UART0_Polling
  187 0000000A         ;initializing op string better
  188 0000000A 487E            LDR              R0,=lenOpStr ;load address to store the length of op str in
  189 0000000C 2100            MOVS             R1,#0
  190 0000000E 7001            STRB             R1,[R0,#0]  ;store the length of the op str as 0
  191 00000010         loopHereInput
  192 00000010 200D            MOVS             R0,#CR      ;load carriage return
  193 00000012 F7FF FFFE       BL               PutChar     ;print carriage return
  194 00000016 200A            MOVS             R0,#LF      ;load line feed
  195 00000018 F7FF FFFE       BL               PutChar     ;print line feed
  196 0000001C 487A            LDR              R0,=PROMPT_STRING
  197 0000001E 211F            MOVS             R1,#31      ;store num bytes in prompt string
  198 00000020 F7FF FFFE       BL               PutStringSB ;print prompt to terminal from mem
  199 00000024 F7FF FFFE       BL               GetChar     ;get command char from terminal
  200 00000028 F7FF FFFE       BL               PutChar     ;show typed char on terminal
  201 0000002C         ;checking if char is lowercase
  202 0000002C 287A            CMP              R0,#'z'     ;check if ASCII is greater than 'z;
  203 0000002E D802            BHI              notLowerCase
  204 00000030 2861            CMP              R0,#'a'
  205 00000032 D300            BLO              notLowerCase ;check if ASCII is less than 'a'
  206 00000034         ;Converting lowercase to uppercase
  207 00000034 3820            SUBS             R0,R0,#32   ;otherwise make uppercase subtract 32
  208 00000036         notLowerCase
  209 00000036 2847            CMP              R0,#'G'
  210 00000038 D006            BEQ              GInstruction
  211 0000003A 2849            CMP              R0,#'I'
  212 0000003C D012            BEQ              IInstruction
  213 0000003E 284C            CMP              R0,#'L'
  214 00000040 D017            BEQ              LInstruction
  215 00000042 2850            CMP              R0,#'P'
  216 00000044 D024            BEQ              PInstruction
  217 00000046         ;otherwise repeat regular 
  218 00000046 E7E3            B                loopHereInput
  219 00000048         ;special instructions
  220 00000048         GInstruction
  221 00000048 200D            MOVS             R0,#CR      ;load carriage return
  222 0000004A F7FF FFFE       BL               PutChar     ;print carriage return
  223 0000004E 200A            MOVS             R0,#LF      ;load line feed
  224 00000050 F7FF FFFE       BL               PutChar     ;print line feed



ARM Macro Assembler    Page 7 CMPE 250 Exercise 6


  225 00000054 203C            MOVS             R0,#'<'     ;load '<'
  226 00000056 F7FF FFFE       BL               PutChar     ;print '<'
  227 0000005A 486C            LDR              R0,=String  ;mem address of string
  228 0000005C 214F            MOVS             R1,#MAX_STRING ;length of max string
  229 0000005E F7FF FFFE       BL               GetStringSB ;branch to get string input 
  230 00000062 E7D5            B                loopHereInput ;branch to start again
  231 00000064         IInstruction
  232 00000064 4869            LDR              R0,=String  ;mem address of op string
  233 00000066 2100            MOVS             R1,#NULL    ;load null character
  234 00000068 7001            STRB             R1,[R0,#0]  ;null char in first byte of op string
  235 0000006A 200D            MOVS             R0,#CR      ;load carriage return
  236 0000006C F7FF FFFE       BL               PutChar     ;print carriage return
  237 00000070 E7CE            B                loopHereInput
  238 00000072         LInstruction
  239 00000072 200D            MOVS             R0,#CR      ;load carriage return
  240 00000074 F7FF FFFE       BL               PutChar     ;print carriage return
  241 00000078 200A            MOVS             R0,#LF      ;load line feed
  242 0000007A F7FF FFFE       BL               PutChar     ;print line feed
  243 0000007E 4864            LDR              R0,=LEN_STR ;mem address of "Length:"
  244 00000080 2107            MOVS             R1,#LEN_LENGTH ;load num characters of "length
  245 00000082 F7FF FFFE       BL               PutStringSB ;print "Length:"
  246 00000086 495F            LDR              R1,=lenOpStr ;load mem addr of length op str
  247 00000088 7808            LDRB             R0,[R1,#0]  ;load value of len op str to R0
  248 0000008A F7FF FFFE       BL               PutNumU     ;print length of op string in dec
  249 0000008E E7BF            B                loopHereInput
  250 00000090         PInstruction
  251 00000090 200D            MOVS             R0,#CR      ;load carriage return
  252 00000092 F7FF FFFE       BL               PutChar     ;print carriage return
  253 00000096 200A            MOVS             R0,#LF      ;load line feed
  254 00000098 F7FF FFFE       BL               PutChar     ;print line feed
  255 0000009C 203E            MOVS             R0,#'>'     ;load '>'
  256 0000009E F7FF FFFE       BL               PutChar     ;print '>'
  257 000000A2 485A            LDR              R0,=String  ;load start mem addr op str
  258 000000A4 495E            LDR              R1,=MAX_STRING ;load length of max string
  259 000000A6 F7FF FFFE       BL               PutStringSB ;branch to print the string
  260 000000AA 203E            MOVS             R0,#'>'     ;load '>'
  261 000000AC F7FF FFFE       BL               PutChar     ;print '>'
  262 000000B0 E7AE            B                loopHereInput
  263 000000B2         
  264 000000B2         ;>>>>>   end main program code <<<<<
  265 000000B2         ;Stay here
  266 000000B2 E7FE            B                .



ARM Macro Assembler    Page 8 CMPE 250 Exercise 6


  267 000000B4                 ENDP
  268 000000B4         ;>>>>> begin subroutine code <<<<<
  269 000000B4         Init_UART0_Polling
                               PROC             {R0-R14}
  270 000000B4         ;****************************************************************
  271 000000B4         ;select/configure UART0 sources 
  272 000000B4         ;enable clocks for UART0 and Port B
  273 000000B4         ;set Port B mux pins to connect to UART0 
  274 000000B4         ;Configure UART0 (register initialization)
  275 000000B4         ;Input Parameter: none
  276 000000B4         ;Output Parameter: none
  277 000000B4         ;no registers but LR, PC, PSR changed after return
  278 000000B4         ;****************************************************************
  279 000000B4 B407            PUSH             {R0-R2}
  280 000000B6         ;code copied from provided PDF
  281 000000B6         ;Select MCGFLLCLK as UART0 clock source
  282 000000B6 485B            LDR              R0,=SIM_SOPT2
  283 000000B8 495B            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  284 000000BA 6802            LDR              R2,[R0,#0]
  285 000000BC 438A            BICS             R2,R2,R1
  286 000000BE 495B            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCLK
  287 000000C0 430A            ORRS             R2,R2,R1
  288 000000C2 6002            STR              R2,[R0,#0]
  289 000000C4         ;Set UART0 for external connection
  290 000000C4 485A            LDR              R0,=SIM_SOPT5
  291 000000C6 495B            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  292 000000C8 6802            LDR              R2,[R0,#0]
  293 000000CA 438A            BICS             R2,R2,R1
  294 000000CC 6002            STR              R2,[R0,#0]
  295 000000CE         ;Enable UART0 module clock
  296 000000CE 485A            LDR              R0,=SIM_SCGC4
  297 000000D0 495A            LDR              R1,=SIM_SCGC4_UART0_MASK
  298 000000D2 6802            LDR              R2,[R0,#0]
  299 000000D4 430A            ORRS             R2,R2,R1
  300 000000D6 6002            STR              R2,[R0,#0]
  301 000000D8         ;Enable PORT B module clock
  302 000000D8 4859            LDR              R0,=SIM_SCGC5
  303 000000DA 4958            LDR              R1,=SIM_SCGC5_PORTB_MASK
  304 000000DC 6802            LDR              R2,[R0,#0]
  305 000000DE 430A            ORRS             R2,R2,R1
  306 000000E0 6002            STR              R2,[R0,#0]
  307 000000E2         ;Select PORT B Pin 2 (D0) for UART0 RX (J8 Pin 01)



ARM Macro Assembler    Page 9 CMPE 250 Exercise 6


  308 000000E2 4858            LDR              R0,=PORTB_PCR2
  309 000000E4 4958            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  310 000000E6 6001            STR              R1,[R0,#0]
  311 000000E8         ; Select PORT B Pin 1 (D1) for UART0 TX (J8 Pin 02)
  312 000000E8 4858            LDR              R0,=PORTB_PCR1
  313 000000EA 4957            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  314 000000EC 6001            STR              R1,[R0,#0]
  315 000000EE         ;Disable UART0 receiver and transmitter
  316 000000EE 4858            LDR              R0,=UART0_BASE
  317 000000F0 210C            MOVS             R1,#UART0_C2_T_R
  318 000000F2 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  319 000000F4 438A            BICS             R2,R2,R1
  320 000000F6 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  321 000000F8         ;Set UART0 for 9600 baud, 8N1 protocol
  322 000000F8 2101            MOVS             R1,#UART0_BDH_9600
  323 000000FA 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  324 000000FC 2138            MOVS             R1,#UART0_BDL_9600
  325 000000FE 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  326 00000100 2100            MOVS             R1,#UART0_C1_8N1
  327 00000102 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  328 00000104 2100            MOVS             R1,#UART0_C3_NO_TXINV
  329 00000106 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  330 00000108 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  331 0000010A 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  332 0000010C 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  333 0000010E 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  334 00000110 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  335 00000112 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  337 00000114 21C0            MOVS             R1,       #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  338 00000116 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  339 00000118         ;Enable UART0 receiver and transmitter
  340 00000118 210C            MOVS             R1,#UART0_C2_T_R
  341 0000011A 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  342 0000011C         ;end code from PDF
  343 0000011C BC07            POP              {R0-R2}
  344 0000011E 4770            BX               LR
  345 00000120                 ENDP
  346 00000120         
  347 00000120         
  348 00000120         PutChar PROC             {R0-R14}
  349 00000120         ;****************************************************************
  350 00000120         ;Polled Transmit 



ARM Macro Assembler    Page 10 CMPE 250 Exercise 6


  351 00000120         ;Description from provided doc:
  352 00000120         ;A polled transmit, (i.e., send character), polls UART0 status 
  353 00000120         ;register 1 for the transmit data register empty (TDRE) condition 
  354 00000120         ;in bit 7. If TDRE = 1, a byte may be transmitted (i.e., sent); 
  355 00000120         ;otherwise, UART0 is not yet ready to transmit a byte, and the
  356 00000120         ;status register must be polled until TDRE = 1.
  357 00000120         ;Input Parameter: R0,  character to send to terminal (unsigned
  358 00000120         ;byte ASCII code)
  359 00000120         ;Output Parameter: none
  360 00000120         ;no registers but LR, PC, PSR changed after return
  361 00000120         ;****************************************************************
  362 00000120         ;code from pdf
  363 00000120         ;Poll TDRE until UART0 ready to transmit
  364 00000120 B40F            PUSH             {R0-R3}
  365 00000122 494B            LDR              R1,=UART0_BASE
  366 00000124 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  367 00000126 790B    PollTx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  368 00000128 4013            ANDS             R3,R3,R2
  369 0000012A D0FC            BEQ              PollTx
  370 0000012C         ;Transmit character stored in R0
  371 0000012C 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  372 0000012E BC0F            POP              {R0-R3}
  373 00000130 4770            BX               LR
  374 00000132                 ENDP
  375 00000132         
  376 00000132         
  377 00000132         GetChar PROC             {R1-R14}
  378 00000132         ;****************************************************************
  379 00000132         ;Polled Recieve 
  380 00000132         ;Description from provided doc:
  381 00000132         ;a polled receive, (i.e., get character), polls UART0 status 
  382 00000132         ;register 1 for the receive data register full (RDRF) condition 
  383 00000132         ;in bit 5. If RDRF = 1, a byte may be read by the KL05, 
  384 00000132         ;(i.e., received); otherwise, UART0 has not yet received a 
  385 00000132         ;byte, and the status register must be polled until RDRF = 1.
  386 00000132         ;Input Parameter: none
  387 00000132         ;Output Parameter: R0, character recieved from terminal unsigned
  388 00000132         ;byte ASCII code)
  389 00000132         ;no registers but R0, LR, PC, PSR changed after return
  390 00000132         ;****************************************************************
  391 00000132         ;code from doc provided
  392 00000132 B40E            PUSH             {R1-R3}



ARM Macro Assembler    Page 11 CMPE 250 Exercise 6


  393 00000134         ;Poll RDRF until UART0 ready to receive
  394 00000134 4946            LDR              R1,=UART0_BASE
  395 00000136 2220            MOVS             R2,#UART0_S1_RDRF_MASK
  396 00000138 790B    PollRx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  397 0000013A 4013            ANDS             R3,R3,R2
  398 0000013C D0FC            BEQ              PollRx
  399 0000013E         ;Receive character and store in R0
  400 0000013E 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  401 00000140 BC0E            POP              {R1-R3}
  402 00000142 4770            BX               LR
  403 00000144                 ENDP
  404 00000144         
  405 00000144         GetStringSB
                               PROC             {R1-R14}
  406 00000144         ;****************************************************************
  407 00000144         ;Inputs string from terminal reventing overrun 
  408 00000144         ;Preventing overrun of the buffer capacity specified in R1, this
  409 00000144         ;subroutine inputs a string from the terminal keyboard to memory 
  410 00000144         ;starting at the address in R0 and adds null termination. It ends 
  411 00000144         ;terminal keyboard input when the user presses the enter key. 
  412 00000144         ;For each of up to R1 - 1 characters typed on the terminal 
  413 00000144         ;keyboard, it uses GetChar to input the character, uses PutChar 
  414 00000144         ;to echo the character to the terminal screen, and stores the 
  415 00000144         ;character at the next position in the string. For any character
  416 00000144         ;typed after the first R1 - 1 characters, it uses GetChar to input 
  417 00000144         ;the character, but it neither stores the character in the string 
  418 00000144         ;nor echoes the character to the terminal screen.When the carriage 
  419 00000144         ;return character has been received, it null terminates the string,
  420 00000144         ;advances the cursor on the terminal screen to the beginning of 
  421 00000144         ;the next line, and returns.
  422 00000144         ;Input Parameter: R1, bytes in string buffer where R0 points
  423 00000144         ; (unsigned word value)
  424 00000144         ; R0, should be mem adress to start at. Not specified in doc
  425 00000144         ;Output Parameter: R0, string buffer in memory for input from 
  426 00000144         ; user (unsigned word address)
  427 00000144         ;no registers but PSR changed after return
  428 00000144         ;Subroutines used:
  429 00000144         ; GetChar
  430 00000144         ; PutChar
  431 00000144         ;****************************************************************
  432 00000144 B53F            PUSH             {LR,R0-R5}
  433 00000146 0003            MOVS             R3,R0       ;copy address to store in to R3



ARM Macro Assembler    Page 12 CMPE 250 Exercise 6


  434 00000148 1E4C            SUBS             R4,R1,#1    ;store R1-1 in R4
  435 0000014A 2200            MOVS             R2,#0       ;initialize r2 as 0 for num chars typed
  436 0000014C         loopHere
  437 0000014C F7FF FFFE       BL               GetChar     ;Get char from terminal (now in R0)
  438 00000150 0015            MOVS             R5,R2       ;r5 1 less then r2 for storage purposes
  439 00000152 1C52            ADDS             R2,R2,#1    ;increment r2
  440 00000154         
  441 00000154 280D            CMP              R0,#CR      ;compare the character typed to carriage return
  442 00000156 D005            BEQ              enterPressed ;if equal branch accordingly
  443 00000158         
  444 00000158 42A2            CMP              R2,R4       ;compare r1-1 with num chars typed so far
  445 0000015A DCF7            BGT              loopHere    ;if r2 > r4 then no output or store
  446 0000015C         
  447 0000015C         ;output and store 
  448 0000015C F7FF FFFE       BL               PutChar     ;output char in r0 to terminal
  449 00000160 5558            STRB             R0,[R3,R5]  ;store in addr r0 inc offset
  450 00000162 E7F3            B                loopHere
  451 00000164         
  452 00000164         enterPressed
  453 00000164 4827            LDR              R0,=lenOpStr ;load address to store the length of op str in
  454 00000166 42A5            CMP              R5,R4       ;if length greater than max length
  455 00000168 DD00            BLE              notExceed
  456 0000016A 0025            MOVS             R5,R4       ;store length as max length
  457 0000016C         notExceed
  458 0000016C 7005            STRB             R5,[R0,#0]  ;store the length of the op str 
  459 0000016E 2000            MOVS             R0,#NULL    ;move equate null into r0 
  460 00000170 5558            STRB             R0,[R3,R5]  ;store null in addr r0 inc offset
  461 00000172         ;MOVS R0,#LF  ;load carriage return
  462 00000172         ;BL PutChar  ;output carriage return to terminal
  463 00000172         ;MOVS R0,#LF  ;load line feed
  464 00000172         ;BL  PutChar  ;print line feed
  465 00000172         
  466 00000172 BD3F            POP              {PC,R0-R5}
  467 00000174 4770            BX               LR
  468 00000176                 ENDP
  469 00000176         
  470 00000176         PutStringSB
                               PROC             {R0-R14}
  471 00000176         ;****************************************************************
  472 00000176         ;Displays string from memory to terminal screen
  473 00000176         ;Preventing overrun of the buffer capacity specified in R1, 
  474 00000176         ;this subroutine displays a null-terminated string to the terminal 



ARM Macro Assembler    Page 13 CMPE 250 Exercise 6


  475 00000176         ;screen from memory starting at the address in R0. It uses PutChar 
  476 00000176         ;to display characters from the string and leaves the terminal 
  477 00000176         ;screen cursor positioned after the last character of the string.
  478 00000176         ;Input Parameters: 
  479 00000176         ;R0: string buffer in memory for output to simulated output stream 
  480 00000176         ; (unsigned word address)
  481 00000176         ;R1: bytes in string buffer where R0 points (unsigned word value)
  482 00000176         ;Output Parameter:
  483 00000176         ; none
  484 00000176         ;no registers but PSR changed after return
  485 00000176         ;Subroutines used:
  486 00000176         ; PutChar
  487 00000176         ;****************************************************************
  488 00000176         
  489 00000176 B50F            PUSH             {LR,R0-R3}
  490 00000178 0002            MOVS             R2,R0       ;copy starting address of string
  491 0000017A 2300            MOVS             R3,#0       ;initialize counter
  492 0000017C         printLoop
  493 0000017C 5CD0            LDRB             R0,[R2,R3]  ;configure input to PutChar correctly with
  494 0000017E         ;offset
  495 0000017E 2800            CMP              R0,#NULL    ;compare to see if null character an
  496 00000180 D004            BEQ              stopPrint   ;if so terminate
  497 00000182         
  498 00000182 F7FF FFFE       BL               PutChar     ;use putchar to output char R0 to terminal   
  499 00000186         
  500 00000186 1C5B            ADDS             R3,R3,#1    ;increment counter
  501 00000188 428B            CMP              R3,R1
  502 0000018A DDF7            BLE              printLoop   ;if the counter is less than or equal to the 
  503 0000018C         stopPrint                            ;num bytes in the string branch and get next
  504 0000018C BD0F            POP              {PC,R0-R3}  ;otherwise restore registers and exit
  505 0000018E 4770            BX               LR
  506 00000190                 ENDP
  507 00000190         
  508 00000190         PutNumU PROC             {R0-R14}
  509 00000190         ;****************************************************************
  510 00000190         ;Displays text decimal representation of value to terminal screen
  511 00000190         ;This subroutine displays the text decimal representation to the
  512 00000190         ;terminal screen of the unsigned word value in R0, using PutChar 
  513 00000190         ;to output each decimal digit character. (For example, if R0 
  514 00000190         ;contains 0x00000100, then 256 should be output 0000000256 would 
  515 00000190         ;also be acceptable.) (hint use divU)
  516 00000190         ;Input Parameters: 



ARM Macro Assembler    Page 14 CMPE 250 Exercise 6


  517 00000190         ;R0: number for output to terminal(unsigned word value)
  518 00000190         ;Output Parameter:
  519 00000190         ; none
  520 00000190         ;no registers but PSR changed after return
  521 00000190         ;Subroutines used:
  522 00000190         ;****************************************************************
  523 00000190 B53F            PUSH             {LR,R0-R5}
  524 00000192 0002            MOVS             R2,R0       ;backup word value in R2
  525 00000194 230A            MOVS             R3,#10      ;store 10 to be the denominator
  526 00000196 2400            MOVS             R4,#0       ;store counter in R4
  527 00000198 0011            MOVS             R1,R2       ;move word value to numerator
  528 0000019A         convertLoop
  529 0000019A 0018            MOVS             R0,R3       ;move 10 to be the denominator
  530 0000019C         
  531 0000019C F7FF FFFE       BL               DIVU        ;use DIVU    
  532 000001A0 B402            PUSH             {R1}        ;store the remainder in the stack
  533 000001A2 1C64            ADDS             R4,R4,#1    ;increment counter
  534 000001A4 0001            MOVS             R1,R0       ;move the quotient so that it will be the ~~~~
  535 000001A6         ;numerator next time around
  536 000001A6         
  537 000001A6 2800            CMP              R0,#0       ;check if quotient is 0, if so done
  538 000001A8 D1F7            BNE              convertLoop ;if quotient not equal 0 go again
  539 000001AA         
  540 000001AA         popLoop
  541 000001AA BC01            POP              {R0}        ;pop individual result to the register r0
  542 000001AC 2530            MOVS             R5,#0x30    ;move hex 30 into the register
  543 000001AE 1940            ADDS             R0,R0,R5    ;add to r0 to make ascii from dec
  544 000001B0 F7FF FFFE       BL               PutChar     ;use putchar to output to the terminal  
  545 000001B4 1E64            SUBS             R4,R4,#1    ;decrement counter
  546 000001B6 2C00            CMP              R4,#0       ;see if counter is back to 0
  547 000001B8 DCF7            BGT              popLoop     ;if counter still positive loop again  
  548 000001BA BD3F            POP              {PC,R0-R5}  ;restore registers
  549 000001BC 4770            BX               LR          ;branch back to where putNUmU was called
  550 000001BE                 ENDP
  551 000001BE         
  552 000001BE         DIVU    PROC             {R2-R14}
  553 000001BE         ;****************************************************************
  554 000001BE         ;Subroutine from lab 4 created to perform integer division
  555 000001BE         ;Input: R0; divisor (denominator)
  556 000001BE         ;Input: R1; dividend (numerator)
  557 000001BE         ;Output: R0; quotient
  558 000001BE         ;Output: R1; remainder



ARM Macro Assembler    Page 15 CMPE 250 Exercise 6


  559 000001BE         ;C: APSR flag: 0 for valid result; 1 for invalid result
  560 000001BE         ;****************************************************************
  561 000001BE 2800            CMP              R0,#0       ;check if divisor (denominator) is already zero
  562 000001C0 D015            BEQ              div0        ;if so branch to div0 to set c flag
  563 000001C2 B40C            PUSH             {R2,R3}     ;store R2 and R3 on the stack
  564 000001C4 2900            CMP              R1,#0       ;check if dividend(numerator) is zero
  565 000001C6 D007            BEQ              zerodiv     ;if so set outputs to 0 and clear C flag
  566 000001C8         
  567 000001C8         ;actual division part
  568 000001C8 2200            MOVS             R2,#0       ;quotient =0 (R2 will be quotient while computing)
  569 000001CA         divuloop
  570 000001CA 4281            CMP              R1,R0       ;while dividend>=divisor
  571 000001CC D302            BLO              divuFinish
  572 000001CE 1A09            SUBS             R1,R1,R0    ;dividend=dividend-divisor
  573 000001D0 1C52            ADDS             R2,R2,#1    ;quotient=quotient+1
  574 000001D2 E7FA            B                divuloop
  575 000001D4         divuFinish
  576 000001D4 0010            MOVS             R0,R2       ;R0 =quotient = p
  577 000001D6         ;R1 = remainder = dividend = q
  578 000001D6 E001            B                clearC      ;branch and clearC then endit
  579 000001D8         zerodiv                              ;if dividing zero by anything the result is 0 rem 0
  580 000001D8 2000            MOVS             R0,#0
  581 000001DA 2100            MOVS             R1,#0
  582 000001DC         clearC
  583 000001DC F3EF 8200       MRS              R2,APSR
  584 000001E0 2320            MOVS             R3,#0x20
  585 000001E2 061B            LSLS             R3,R3,#24
  586 000001E4 439A            BICS             R2,R2,R3
  587 000001E6 F382 8800       MSR              APSR,R2
  588 000001EA BC0C            POP              {R2,R3}     ;restore R2 and R3 from stack
  589 000001EC E008            B                endit
  590 000001EE         div0                                 ;time to set the C flag and leave all else unchanged
  591 000001EE B403            PUSH             {R0,R1}     ;push input parameters to stack
  592 000001F0 F3EF 8000       MRS              R0,APSR
  593 000001F4 2120            MOVS             R1,#0x20
  594 000001F6 0609            LSLS             R1,R1,#24
  595 000001F8 4308            ORRS             R0,R0,R1
  596 000001FA F380 8800       MSR              APSR,R0
  597 000001FE BC03            POP              {R0,R1}     ;restore input parameters from stack
  598 00000200         endit
  599 00000200 4770            BX               LR
  600 00000202                 ENDP



ARM Macro Assembler    Page 16 CMPE 250 Exercise 6


  601 00000202         
  602 00000202         ;>>>>>   end subroutine code <<<<<
  603 00000202 00 00           ALIGN
  604 00000204         ;****************************************************************
  605 00000204         ;Vector Table Mapped to Address 0 at Reset
  606 00000204         ;Linker requires __Vectors to be exported
  607 00000204 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              0000004F 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 
              40048034 
              00000400 
              40048038 
              4004A008 
              01000200 
              4004A004 
              4006A000 
              00000000         AREA             RESET, DATA, READONLY
  608 00000000                 EXPORT           __Vectors
  609 00000000                 EXPORT           __Vectors_End
  610 00000000                 EXPORT           __Vectors_Size
  611 00000000                 IMPORT           __initial_sp
  612 00000000                 IMPORT           Dummy_Handler
  613 00000000                 IMPORT           HardFault_Handler
  614 00000000         __Vectors
  615 00000000         ;ARM core vectors
  616 00000000 00000000        DCD              __initial_sp ;00:end of stack
  617 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  618 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  619 0000000C 00000000        DCD              HardFault_Handler ;03:hard fault
  620 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  621 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  622 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)



ARM Macro Assembler    Page 17 CMPE 250 Exercise 6


  623 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  624 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  625 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  626 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  627 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
  628 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  629 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  630 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (PendableSrvReq)
  631 0000003C         ;   pendable request 
  632 0000003C         ;   for system service)
  633 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
  634 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 transfer 
  635 00000044         ;   complete/error
  636 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 transfer
  637 00000048         ;   complete/error
  638 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 transfer
  639 0000004C         ;   complete/error
  640 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 transfer
  641 00000050         ;   complete/error
  642 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  643 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command complete/
  644 00000058         ;   read collision
  645 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
  646 0000005C         ;   low-voltage warning
  647 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
  648 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  649 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
  650 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
  651 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
  652 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status; error)
  653 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
  654 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
  655 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  656 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  657 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  658 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  659 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
  660 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  661 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
  662 00000098 00000000        DCD              Dummy_Handler ;38:PIT
  663 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
  664 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)



ARM Macro Assembler    Page 18 CMPE 250 Exercise 6


  665 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  666 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  667 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  668 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  669 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
  670 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
  671 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
  672 000000C0         __Vectors_End
  673 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
  674 000000C0                 ALIGN
  675 000000C0         ;****************************************************************
  676 000000C0         ;Constants
  677 000000C0                 AREA             MyConst,DATA,READONLY
  678 00000000         ;>>>>> begin constants here <<<<<
  679 00000000 54 79 70 
              65 20 61 
              20 73 74 
              72 69 6E 
              67 20 63 
              6F 6D 6D 
              61 6E 64 
              20 28 47 
              2C 49 2C 
              4C 2C 50 
              29 3A    PROMPT_STRING
                               DCB              "Type a string command (G,I,L,P):"
  680 00000020 4C 65 6E 
              67 74 68 
              3A       LEN_STR DCB              "Length:"
  681 00000027         ;>>>>>   end constants here <<<<<
  682 00000027 00              ALIGN
  683 00000028         ;****************************************************************
  684 00000028         ;Variables
  685 00000028                 AREA             MyData,DATA,READWRITE
  686 00000000         ;>>>>> begin variables here <<<<<
  687 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 19 CMPE 250 Exercise 6


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       String  SPACE            MAX_STRING
  688 0000004F 00 00   lenOpStr
                               SPACE            2           ;length of the operational string
  689 00000051         ;>>>>>   end variables here <<<<<
  690 00000051 00 00 00        ALIGN
  691 00000054                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\objects\
exercise06.d -o.\objects\exercise06.o -IC:\Users\Atticus\AppData\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Inc
lude -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSION SETA 531" --predefine="MK
L05Z32xxx4 SETA 1" --list=.\listings\exercise06.lst Exercise06.s
