


ARM Macro Assembler    Page 1 Lab Exercise Ten: Timer Driver Input Timing


    1 00000000                 TTL              Lab Exercise Ten: Timer Driver Input Timing
    2 00000000         ;****************************************************************
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;(What does the program do?)
    5 00000000         ;Name:  <Atticus Russell>
    6 00000000         ;Date:  <4/8/2021>
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  <Section 01L1, Thursday, 2:00-3:55>
    9 00000000         ;---------------------------------------------------------------
   10 00000000         ;Keil Template for KL05
   11 00000000         ;R. W. Melton
   12 00000000         ;September 13, 2020
   13 00000000         ;****************************************************************
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;****************************************************************
   18 00000000         ;Include files
   19 00000000                 GET              MKL05Z4.s   ;Included by start.s
   23 00000000         ;****************************************************************
   24 00000000         ;EQUates
   25 00000000 00000010 
                       NamePromptSize
                               EQU              16          ;
   26 00000000 00000008 
                       CountSuffixSize
                               EQU              8           ;
   27 00000000 0000000D 
                       DatePromptSize
                               EQU              13          ;
   28 00000000 00000022 
                       TAPromptSize
                               EQU              34          ;
   29 00000000 00000014 
                       EndMessageSize
                               EQU              20          ;
   30 00000000         
   31 00000000         ;Below EQUates are from lab exercise 7
   32 00000000         ;---------------------------------------------------------------
   33 00000000         ; Queue management record field offsets
   34 00000000 00000000 
                       IN_PTR  EQU              0
   35 00000000 00000004 



ARM Macro Assembler    Page 2 Lab Exercise Ten: Timer Driver Input Timing


                       OUT_PTR EQU              4
   36 00000000 00000008 
                       BUF_STRT
                               EQU              8
   37 00000000 0000000C 
                       BUF_PAST
                               EQU              12
   38 00000000 00000010 
                       BUF_SIZE
                               EQU              16
   39 00000000 00000011 
                       NUM_ENQD
                               EQU              17
   40 00000000         ; Queue structure sizes
   41 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4           ;Queue contents
   42 00000000 00000012 
                       Q_REC_SZ
                               EQU              18          ;Queue management record
   43 00000000         ; Number of bytes in prompts
   44 00000000 00000020 
                       PROMPT_QUEUE_LEN
                               EQU              32          ;
   45 00000000 00000007 
                       FAILURE_STR_LEN
                               EQU              7           ;
   46 00000000 00000014 
                       ENQUEUE_STR_LEN
                               EQU              20          ;
   47 00000000 00000007 
                       SUCCESS_STR_LEN
                               EQU              7           ;
   48 00000000 00000006 
                       STATUS_STR_LEN
                               EQU              6           ;
   49 00000000 00000004 
                       IN_STR_LEN
                               EQU              4           ;
   50 00000000 00000008 
                       OUT_STR_LEN
                               EQU              8           ;



ARM Macro Assembler    Page 3 Lab Exercise Ten: Timer Driver Input Timing


   51 00000000 00000003 
                       NUM_STR_LEN
                               EQU              3           ;
   52 00000000 00000038 
                       HELP_STR_LEN
                               EQU              56          ;
   53 00000000         ;---------------------------------------------------------------
   54 00000000         ;For text output and related subroutines
   55 00000000 0000000D 
                       CR      EQU              0x0D        ;moves cursor beginning line
   56 00000000 0000000A 
                       LF      EQU              0x0A        ;adds new line
   57 00000000 00000000 
                       NULL    EQU              0x00        ;the null character
   58 00000000         
   59 00000000         ;****************************************************************
   60 00000000         ;Program
   61 00000000         ;Linker requires Reset_Handler
   62 00000000                 AREA             MyCode,CODE,READONLY
   63 00000000                 ENTRY
   64 00000000                 EXPORT           Reset_Handler
   65 00000000                 IMPORT           Startup
   66 00000000         Reset_Handler
                               PROC             {}
   67 00000000         main
   68 00000000         ;---------------------------------------------------------------
   69 00000000         ;Mask interrupts
   70 00000000 B672            CPSID            I
   71 00000002         ;KL05 system startup with 48-MHz system clock
   72 00000002 F7FF FFFE       BL               Startup
   73 00000006         ;---------------------------------------------------------------
   74 00000006         ;>>>>> begin main program code <<<<
   75 00000006 F7FF FFFE       BL               Init_UART0_IRQ
   76 0000000A 2700            MOVS             R7,#0
   77 0000000C         mainLoop
   78 0000000C         ;Clear runstopwatch -> set equal 0
   79 0000000C 48E2            LDR              R0,=RunStopWatch
   80 0000000E 2100            MOVS             R1,#0
   81 00000010 7001            STRB             R1,[R0,#0]
   82 00000012 48E2            LDR              R0,=Count
   83 00000014 6001            STR              R1,[R0,#0]
   84 00000016         ;init PIT to initialize the KL05 PIT to generate an interrupt 



ARM Macro Assembler    Page 4 Lab Exercise Ten: Timer Driver Input Timing


   85 00000016         ;from channel zero every 0.01s.
   86 00000016 F7FF FFFE       BL               Init_PIT_IRQ
   87 0000001A         ;Unmask interrupts (CPSIE I
   88 0000001A B662            CPSIE            I
   89 0000001C         ;prompt user PutStr
   90 0000001C 2F00            CMP              R7,#0
   91 0000001E D102            BNE              tryDatePrompt
   92 00000020 48DF            LDR              R0,=Name_Prompt
   93 00000022 2110            MOVS             R1,#NamePromptSize
   94 00000024 E008            B                printThisPrompt
   95 00000026         tryDatePrompt
   96 00000026 2F01            CMP              R7,#1
   97 00000028 D102            BNE              tryTAPrompt
   98 0000002A 48DE            LDR              R0,=Date_Prompt
   99 0000002C 210D            MOVS             R1,#DatePromptSize
  100 0000002E E003            B                printThisPrompt
  101 00000030         tryTAPrompt
  102 00000030 2F02            CMP              R7,#2
  103 00000032 D126            BNE              endMain
  104 00000034 48DC            LDR              R0,=TA_Prompt
  105 00000036 2122            MOVS             R1,#TAPromptSize
  106 00000038         
  107 00000038         printThisPrompt
  108 00000038 F7FF FFFE       BL               PutStringSB
  109 0000003C F7FF FFFE       BL               CRLF
  110 00000040 203E            MOVS             R0,#'>'
  111 00000042 F7FF FFFE       BL               PutChar
  112 00000046         ;clear Count (the global var)
  113 00000046 2100            MOVS             R1,#0
  114 00000048 48D4            LDR              R0,=Count
  115 0000004A 6001            STR              R1,[R0,#0]
  116 0000004C         ;Set RSW to 1
  117 0000004C 2101            MOVS             R1,#1
  118 0000004E 48D2            LDR              R0,=RunStopWatch
  119 00000050 7001            STRB             R1,[R0,#0]
  120 00000052         ;call getString for user input and echo to terminal
  121 00000052 48D6            LDR              R0,=StringMem
  122 00000054 2150            MOVS             R1,#80
  123 00000056 F7FF FFFE       BL               GetStringSB
  124 0000005A F7FF FFFE       BL               CRLF        ;return
  125 0000005E 203C            MOVS             R0,#'<'
  126 00000060 F7FF FFFE       BL               PutChar



ARM Macro Assembler    Page 5 Lab Exercise Ten: Timer Driver Input Timing


  127 00000064         ;Clear RSW
  128 00000064 48CC            LDR              R0,=RunStopWatch
  129 00000066 2100            MOVS             R1,#0
  130 00000068 7001            STRB             R1,[R0,#0]
  131 0000006A         ;Print the time -> print the Count
  132 0000006A 49CC            LDR              R1,=Count
  133 0000006C 6808            LDR              R0,[R1,#0]
  134 0000006E F7FF FFFE       BL               PutNumU
  135 00000072         ;print the count suffix
  136 00000072 48CF            LDR              R0,=Count_Suffix
  137 00000074 2108            MOVS             R1,#CountSuffixSize
  138 00000076 F7FF FFFE       BL               PutStringSB
  139 0000007A F7FF FFFE       BL               CRLF
  140 0000007E 1C7F            ADDS             R7,R7,#1    ;increment loop counter
  141 00000080 E7C4            B                mainLoop
  142 00000082         ;print goodbye and end
  143 00000082         endMain
  144 00000082 48CC            LDR              R0,=EndMessage
  145 00000084 2114            MOVS             R1,#EndMessageSize
  146 00000086 F7FF FFFE       BL               PutStringSB
  147 0000008A         ;>>>>>   end main program code <<<<<
  148 0000008A         ;Stay here
  149 0000008A E7FE            B                .
  150 0000008C                 ENDP
  151 0000008C         ;>>>>> begin subroutine code <<<<<
  152 0000008C         PIT_ISR PROC             {R0-R14}
  153 0000008C         ;****************************************************************
  154 0000008C         ;ISR for the PIT module. On a PIT interrupt, if the (byte) variable 
  155 0000008C         ;RunStopWatch is not zero, PIT_ISR increments the (word) variable Count; 
  156 0000008C         ;otherwise it leaves Count unchanged. In either case, make sure the ISR clears 
  157 0000008C         ;the interrupt condition before exiting. You must write the ISR so that no 
  158 0000008C         ;registers have changed value after return. 
  159 0000008C         ;(Note: the Cortex-M0+ automatically preserves R0–R3, 
  160 0000008C         ;R12, LR, PC, and PSR for ISRs.)
  161 0000008C         ;****************************************************************
  162 0000008C B672            CPSID            I           ;Mask interrupts
  163 0000008E         ;push any registers used except R0–R3, R12
  164 0000008E         ;       if (RunStopWatch) {
  165 0000008E 48C2            LDR              R0,=RunStopWatch ;load addr into r0
  166 00000090 7800            LDRB             R0,[R0,#0]  ;load value RSW
  167 00000092 2800            CMP              R0,#0       ;compare with zero
  168 00000094 D003            BEQ              PITclr_int



ARM Macro Assembler    Page 6 Lab Exercise Ten: Timer Driver Input Timing


  169 00000096         ;       Increment Count
  170 00000096 48C1            LDR              R0,=Count
  171 00000098 6801            LDR              R1,[R0,#0]
  172 0000009A 1C49            ADDS             R1,R1,#1
  173 0000009C 6001            STR              R1,[R0,#0]
  174 0000009E         ;       }
  175 0000009E         ;       clear interrupt
  176 0000009E         PITclr_int
  177 0000009E 48CC            LDR              R0,=PIT_CH0_BASE
  178 000000A0 2101            MOVS             R1,#PIT_TFLG_TIF_MASK
  179 000000A2 60C1            STR              R1,[R0,#PIT_TFLG_OFFSET]
  180 000000A4         ;       return   
  181 000000A4         ;    
  182 000000A4         ; Pop any registers pushed above 
  183 000000A4 B662            CPSIE            I           ; Unmask other interrupts ;CPSIE I 
  184 000000A6 4770            BX               LR          ; Return 
  185 000000A8         ;POP  {PC}
  186 000000A8                 ENDP
  187 000000A8         
  188 000000A8         Init_PIT_IRQ
                               PROC             {R0-R14}
  189 000000A8         ;****************************************************************
  190 000000A8         ;Description:
  191 000000A8         ; initialize the KL05 as discussed in class and 
  192 000000A8         ; presented in the class notes for an interrupt every 0.01 s from PIT channel
  193 000000A8         ; 0. You must write the subroutine so that no registers have changed value 
  194 000000A8         ; after return. 
  195 000000A8         ;Input Parameter:
  196 000000A8         ; none
  197 000000A8         ;Output Parameter:
  198 000000A8         ; none
  199 000000A8         ;modified registers:
  200 000000A8         ; none
  201 000000A8         ;subroutines utilized:
  202 000000A8         ; 
  203 000000A8         ;****************************************************************
  204 000000A8         ;   Push any registers that will be modified
  205 000000A8 B40F            PUSH             {R0-R3}
  206 000000AA         ;   Enable module clock for PIT (SIM_SCGC6)
  207 000000AA 48CA            LDR              R0,=SIM_SCGC6
  208 000000AC 49CA            LDR              R1,=SIM_SCGC6_PIT_MASK
  209 000000AE 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC6 value



ARM Macro Assembler    Page 7 Lab Exercise Ten: Timer Driver Input Timing


  210 000000B0 430A            ORRS             R2,R2,R1    ;only PIT bit set
  211 000000B2 6002            STR              R2,[R0,#0]  ;update SIM_SCGC6
  212 000000B4         ;   Disable PIT timer 0 (PIT_TCTRL0) 
  213 000000B4 48C6            LDR              R0,=PIT_CH0_BASE
  214 000000B6 49C9            LDR              R1,=PIT_TCTRL_TEN_MASK
  215 000000B8 6882            LDR              R2,[R0,#PIT_TCTRL_OFFSET]
  216 000000BA 438A            BICS             R2,R2,R1
  217 000000BC 6082            STR              R2,[R0,#PIT_TCTRL_OFFSET]
  218 000000BE         ;   Set PIT IRQ priority to 0 (NVIC_IPR5)
  219 000000BE         ;PIT_IRQ_PRI EQU 0 ;Highest priority
  220 000000BE         ;Set PIT interrupt priority
  221 000000BE 48C8            LDR              R0,=PIT_IPR
  222 000000C0 49C8            LDR              R1,=(NVIC_IPR_PIT_MASK)
  223 000000C2         ;LDR Rk,=(PIT_IRQ_PRI << PIT_PRI_POS)
  224 000000C2 6802            LDR              R2,[R0,#0]
  225 000000C4 438A            BICS             R2,R2,R1    ;bit clear sets it to zero
  226 000000C6         ;ORRS Rl,Rl,Rk  ;general case to set a bit we need both ^
  227 000000C6 6001            STR              R1,[R0,#0]
  228 000000C8         ;   Clear any pending PIT interrupts (NVIC_ICPR)
  229 000000C8 48C7            LDR              R0,=NVIC_ICPR
  230 000000CA 49C8            LDR              R1,=PIT_IRQ_MASK
  231 000000CC 6001            STR              R1,[R0,#0]
  232 000000CE         ;   Unmask PIT interupts (NVIC_ISER)
  233 000000CE         ;Unmask PIT interrupts
  234 000000CE 48C8            LDR              R0,=NVIC_ISER
  235 000000D0 49C6            LDR              R1,=PIT_IRQ_MASK
  236 000000D2 6001            STR              R1,[R0,#0]
  237 000000D4         ;   Enable PIT module (PIT_MCR)
  238 000000D4 48C7            LDR              R0,=PIT_BASE
  239 000000D6 49C1            LDR              R1,=PIT_MCR_EN_FRZ
  240 000000D8 6001            STR              R1,[R0,#PIT_MCR_OFFSET]
  241 000000DA         ;   Set PIT timer 0 period for 0.01 s (PIT_LDVAL0)
  242 000000DA 48BD            LDR              R0,=PIT_CH0_BASE
  243 000000DC 49C6            LDR              R1,=PIT_LDVAL_10ms
  244 000000DE 6001            STR              R1,[R0,#PIT_LDVAL_OFFSET]
  245 000000E0         ;   Enable PIT timer 0 with interrupt (PIT_TCTRL0)
  246 000000E0 48BB            LDR              R0,=PIT_CH0_BASE
  247 000000E2 2103            MOVS             R1,#PIT_TCTRL_CH_IE
  248 000000E4 6081            STR              R1,[R0,#PIT_TCTRL_OFFSET]
  249 000000E6         ;   Pop any registers pushed
  250 000000E6 BC0F            POP              {R0-R3}
  251 000000E8         ;   Return



ARM Macro Assembler    Page 8 Lab Exercise Ten: Timer Driver Input Timing


  252 000000E8 4770            BX               LR
  253 000000EA                 ENDP
  254 000000EA         
  255 000000EA         UART0_ISR
                               PROC             {R0-R14}
  256 000000EA         ;****************************************************************
  257 000000EA         ;ISR that handles UART0 transmit and recieve interrupts. You 
  258 000000EA         ;must write the ISR so that no registers have changed value after 
  259 000000EA         ;return. (Note: the Cortex-M0+ automatically preserves R0–R3, 
  260 000000EA         ;R12, LR, PC, and PSR for ISRs.)
  261 000000EA         ;****************************************************************
  262 000000EA B672            CPSID            I           ;Mask interrupts
  263 000000EC B500            PUSH             {LR}
  264 000000EE         ;push any registers used except R0–R3, R12
  265 000000EE         ;interrupt source can be found in UART0_S1
  266 000000EE 4BC3            LDR              R3,=UART0_BASE
  267 000000F0 2180            MOVS             R1,#UART0_C2_TIE_MASK
  268 000000F2         ;  if (TxInteruptEnabled) then ;TIE = 1 in UART0_C2 
  269 000000F2 78DA            LDRB             R2,[R3,#UART0_C2_OFFSET]
  270 000000F4 400A            ANDS             R2,R2,R1    ;if the bit was set non zero value 
  271 000000F6 2A00            CMP              R2,#0
  272 000000F8 D00C            BEQ              if_TIE_0
  273 000000FA         ;   if (TxInterrupt) then ;TDRE = 1 in UART0_S1 
  274 000000FA 2180            MOVS             R1,#UART0_S1_TDRE_MASK
  275 000000FC 791A            LDRB             R2,[R3,#UART0_S1_OFFSET]
  276 000000FE 400A            ANDS             R2,R2,R1    ;if the bit was set non zero value 
  277 00000100 2A00            CMP              R2,#0
  278 00000102 D007            BEQ              if_TIE_0
  279 00000104         ;    Dequeue character from TxQueue 
  280 00000104 49AC            LDR              R1,=TxQRecord
  281 00000106 F7FF FFFE       BL               Dequeue
  282 0000010A D201            BCS              unsuccessful_DQ
  283 0000010C         ;    if (dequeue successful) then 
  284 0000010C         ;     Write character to UART0_D ;Tx data reg. 
  285 0000010C 71D8            STRB             R0,[R3,#UART0_D_OFFSET]
  286 0000010E E001            B                if_TIE_0
  287 00000110         ;    else
  288 00000110         unsuccessful_DQ
  289 00000110         ;     Disable TxInterrupt ;UART0_C2_T_RI 
  290 00000110 202C            MOVS             R0,#UART0_C2_T_RI
  291 00000112 70D8            STRB             R0,[R3,#UART0_C2_OFFSET]
  292 00000114         if_TIE_0



ARM Macro Assembler    Page 9 Lab Exercise Ten: Timer Driver Input Timing


  293 00000114         ;  if (RxInterrupt) then ;RDRF = 1 in UART0_S1 
  294 00000114 2120            MOVS             R1,#UART0_S1_RDRF_MASK
  295 00000116 791A            LDRB             R2,[R3,#UART0_S1_OFFSET]
  296 00000118 400A            ANDS             R2,R2,R1    ;if the bit was set non zero value 
  297 0000011A 2A00            CMP              R2,#0
  298 0000011C D003            BEQ              endGoodNaming
  299 0000011E         ;   Read character from UART0_D ;receive data register 
  300 0000011E 79D8            LDRB             R0,[R3,#UART0_D_OFFSET]
  301 00000120         ;   Enqueue character in RxQueue 
  302 00000120 49A6            LDR              R1,=RxQRecord
  303 00000122 F7FF FFFE       BL               Enqueue
  304 00000126         ;   ;Character lost if RxQueue full 
  305 00000126         endGoodNaming
  306 00000126         ; Pop any registers pushed above 
  307 00000126 B662            CPSIE            I           ; Unmask other interrupts ;CPSIE I 
  308 00000128 BD00            POP              {PC}
  309 0000012A                 ENDP
  310 0000012A         
  311 0000012A         Init_UART0_IRQ
                               PROC             {R0-R14}
  312 0000012A         ;****************************************************************
  313 0000012A         ;Description:
  314 0000012A         ; This subroutine initializes the KL05 for interrupt -based serial
  315 0000012A         ; I/0 with UART0 using the format: 1 start bit, 8 data bits, no 
  316 0000012A         ; parity, 1 stop bit at 9600 baud. same format and speed as previous
  317 0000012A         ; but with interrupts instead of polling. Should configure UART0,
  318 0000012A         ; initialize the UART0 interrupt in NVIC, and should initialize the 
  319 0000012A         ; receive and transmit queue management record structures (RxQRecord
  320 0000012A         ; and TxQRecord) for 80-character queue buffers (RxQBuffer and 
  321 0000012A         ; TxQBuffer, respectively) using InitQueue from Lab Exercise Seven. 
  322 0000012A         ; (Suggestion: copy Init_UART0_Polling that has been used since 
  323 0000012A         ; Lab Exercise Five, and modify it to use interrupts instead of 
  324 0000012A         ; polling, including changing UART0 initialization to support 
  325 0000012A         ; UART0_ISR and calling InitQueue from Lab Exercise Seven to 
  326 0000012A         ; initialize the receive and transmit queue management record 
  327 0000012A         ; structures.)   
  328 0000012A         ;Input Parameter:
  329 0000012A         ; none
  330 0000012A         ;Output Parameter:
  331 0000012A         ; none
  332 0000012A         ;modified registers:
  333 0000012A         ; none



ARM Macro Assembler    Page 10 Lab Exercise Ten: Timer Driver Input Timing


  334 0000012A         ;subroutines utilized:
  335 0000012A         ; 
  336 0000012A         ;****************************************************************
  337 0000012A B507            PUSH             {LR,R0-R2}
  338 0000012C         ;code copied from provided PDF
  339 0000012C         ;Select MCGFLLCLK as UART0 clock source
  340 0000012C 48B6            LDR              R0,=SIM_SOPT2
  341 0000012E 49B7            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  342 00000130 6802            LDR              R2,[R0,#0]
  343 00000132 438A            BICS             R2,R2,R1
  344 00000134 49B6            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCLK
  345 00000136 430A            ORRS             R2,R2,R1
  346 00000138 6002            STR              R2,[R0,#0]
  347 0000013A         ;Set UART0 for external connection
  348 0000013A 48B6            LDR              R0,=SIM_SOPT5
  349 0000013C 49B6            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  350 0000013E 6802            LDR              R2,[R0,#0]
  351 00000140 438A            BICS             R2,R2,R1
  352 00000142 6002            STR              R2,[R0,#0]
  353 00000144         ;Enable UART0 module clock
  354 00000144 48B5            LDR              R0,=SIM_SCGC4
  355 00000146 49B6            LDR              R1,=SIM_SCGC4_UART0_MASK
  356 00000148 6802            LDR              R2,[R0,#0]
  357 0000014A 430A            ORRS             R2,R2,R1
  358 0000014C 6002            STR              R2,[R0,#0]
  359 0000014E         ;Enable PORT B module clock
  360 0000014E 48B5            LDR              R0,=SIM_SCGC5
  361 00000150 49B3            LDR              R1,=SIM_SCGC5_PORTB_MASK
  362 00000152 6802            LDR              R2,[R0,#0]
  363 00000154 430A            ORRS             R2,R2,R1
  364 00000156 6002            STR              R2,[R0,#0]
  365 00000158         ;Select PORT B Pin 2 (D0) for UART0 RX (J8 Pin 01)
  366 00000158 48B3            LDR              R0,=PORTB_PCR2
  367 0000015A 49B4            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  368 0000015C 6001            STR              R1,[R0,#0]
  369 0000015E         ; Select PORT B Pin 1 (D1) for UART0 TX (J8 Pin 02)
  370 0000015E 48B4            LDR              R0,=PORTB_PCR1
  371 00000160 49B2            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  372 00000162 6001            STR              R1,[R0,#0]
  373 00000164         ;Set UART0 IRQ priority 
  374 00000164 48B3            LDR              R0,=UART0_IPR
  375 00000166         ;LDR R1,=NVIC_IPR_UART0_MASK 



ARM Macro Assembler    Page 11 Lab Exercise Ten: Timer Driver Input Timing


  376 00000166 4AB4            LDR              R2,=NVIC_IPR_UART0_PRI_3
  377 00000168 6803            LDR              R3,[R0,#0]
  378 0000016A         ;BICS R3,R3,R1 
  379 0000016A 4313            ORRS             R3,R3,R2
  380 0000016C 6003            STR              R3,[R0,#0]
  381 0000016E         ;Clear any pending UART0 interrupts 
  382 0000016E 489E            LDR              R0,=NVIC_ICPR
  383 00000170 49B2            LDR              R1,=NVIC_ICPR_UART0_MASK
  384 00000172 6001            STR              R1,[R0,#0]
  385 00000174         ;Unmask UART0 interrupts 
  386 00000174 489E            LDR              R0,=NVIC_ISER
  387 00000176 49B1            LDR              R1,=NVIC_ISER_UART0_MASK
  388 00000178 6001            STR              R1,[R0,#0]
  389 0000017A         ;Disable UART0 receiver and transmitter
  390 0000017A 48A0            LDR              R0,=UART0_BASE
  391 0000017C 210C            MOVS             R1,#UART0_C2_T_R
  392 0000017E 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  393 00000180 438A            BICS             R2,R2,R1
  394 00000182 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  395 00000184         ;Set UART0 for 9600 baud, 8N1 protocol
  396 00000184 2101            MOVS             R1,#UART0_BDH_9600
  397 00000186 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  398 00000188 2138            MOVS             R1,#UART0_BDL_9600
  399 0000018A 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  400 0000018C 2100            MOVS             R1,#UART0_C1_8N1
  401 0000018E 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  402 00000190 2100            MOVS             R1,#UART0_C3_NO_TXINV
  403 00000192 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  404 00000194 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  405 00000196 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  406 00000198 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  407 0000019A 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  408 0000019C 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  409 0000019E 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  411 000001A0 21C0            MOVS             R1,       #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  412 000001A2 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  413 000001A4         ;Enable UART0 receiver and transmitter
  414 000001A4 212C            MOVS             R1,#UART0_C2_T_RI ;edited this for IRQ
  415 000001A6 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  416 000001A8         ;end code from PDF
  417 000001A8 4885            LDR              R0,=TxQBuffer
  418 000001AA 4983            LDR              R1,=TxQRecord



ARM Macro Assembler    Page 12 Lab Exercise Ten: Timer Driver Input Timing


  419 000001AC 2250            MOVS             R2,#80
  420 000001AE F7FF FFFE       BL               InitQueue
  421 000001B2 4884            LDR              R0,=RxQBuffer
  422 000001B4 4981            LDR              R1,=RxQRecord
  423 000001B6 2250            MOVS             R2,#80
  424 000001B8 F7FF FFFE       BL               InitQueue
  425 000001BC         
  426 000001BC BD07            POP              {PC,R0-R2}
  427 000001BE                 ENDP
  428 000001BE         
  429 000001BE         PutChar PROC             {R0-R14}
  430 000001BE         ;****************************************************************
  431 000001BE         ;Description:
  432 000001BE         ; Enqueues the character from R0 to the transmit queue
  433 000001BE         ;Input Parameter:
  434 000001BE         ; R0: character to enqueue (unsigned byte ASCII code)
  435 000001BE         ;Output Parameter:
  436 000001BE         ; none
  437 000001BE         ;modified registers:
  438 000001BE         ; nothing but PSR
  439 000001BE         ;****************************************************************
  440 000001BE B503            PUSH             {LR,R0-R1}
  441 000001C0 497D            LDR              R1,=TxQRecord ;load addr TxQRecord
  442 000001C2         tryEnqueueLoop
  443 000001C2 B672            CPSID            I
  444 000001C4 F7FF FFFE       BL               Enqueue     ;put char in R0 into TxQBuffer
  445 000001C8 B662            CPSIE            I
  446 000001CA D2FA            BCS              tryEnqueueLoop ;if c set (Enqueue failed) try again  
  447 000001CC         ;enable transmit interrupt
  448 000001CC 488B            LDR              R0,=UART0_BASE
  449 000001CE 21AC            MOVS             R1,#UART0_C2_TI_RI
  450 000001D0 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  451 000001D2 BD03            POP              {PC,R0-R1}
  452 000001D4                 ENDP
  453 000001D4         
  454 000001D4         GetChar PROC             {R1-R14}
  455 000001D4         ;****************************************************************
  456 000001D4         ;Description:
  457 000001D4         ; Dequeues a character from the recieve queue and returns it in
  458 000001D4         ; R0
  459 000001D4         ;Input Parameter:
  460 000001D4         ; none



ARM Macro Assembler    Page 13 Lab Exercise Ten: Timer Driver Input Timing


  461 000001D4         ;Output Parameter:
  462 000001D4         ; R0: returned character (unsigned byte ASCII code)
  463 000001D4         ;modified registers:
  464 000001D4         ; Nothing but output parameter registers and PSR
  465 000001D4         ;subroutines utilized:
  466 000001D4         ; Dequeue
  467 000001D4         ;****************************************************************
  468 000001D4         ;code from doc provided
  469 000001D4 B502            PUSH             {LR,R1}
  470 000001D6 4979            LDR              R1,=RxQRecord ;load addr RxQRecord
  471 000001D8         tryDequeueLoop
  472 000001D8 B672            CPSID            I
  473 000001DA F7FF FFFE       BL               Dequeue     ;R0<- char from RxQBuffer
  474 000001DE B662            CPSIE            I
  475 000001E0 D2FA            BCS              tryDequeueLoop ;if c set (Dequeue failed) try again
  476 000001E2 BD02            POP              {PC,R1}
  477 000001E4                 ENDP
  478 000001E4         
  479 000001E4         CRLF    PROC             {R0-R14}
  480 000001E4         ;****************************************************************
  481 000001E4         ;Description:
  482 000001E4         ; This subroutine outputs a carriage return and a line-feed to
  483 000001E4         ; the terminal screen.
  484 000001E4         ;Input Parameter:
  485 000001E4         ; none
  486 000001E4         ;Output Parameter:
  487 000001E4         ; none
  488 000001E4         ;modified registers:
  489 000001E4         ; none
  490 000001E4         ;subroutines utilized:
  491 000001E4         ; PutChar
  492 000001E4         ;****************************************************************
  493 000001E4 B501            PUSH             {LR,R0}
  494 000001E6 200D            MOVS             R0,#CR      ;load carriage return
  495 000001E8 F7FF FFFE       BL               PutChar     ;print carriage return
  496 000001EC 200A            MOVS             R0,#LF      ;load line feed
  497 000001EE F7FF FFFE       BL               PutChar     ;print line feed
  498 000001F2 BD01            POP              {PC,R0}
  499 000001F4 4770            BX               LR
  500 000001F6                 ENDP
  501 000001F6         
  502 000001F6         JustClearC



ARM Macro Assembler    Page 14 Lab Exercise Ten: Timer Driver Input Timing


                               PROC             {R0-R14}
  503 000001F6         ;****************************************************************
  504 000001F6         ;Description:
  505 000001F6         ; A subroutine with the sole purpose of setting the PSR 
  506 000001F6         ; bit "C" to 0
  507 000001F6         ;Input Parameter:
  508 000001F6         ; none
  509 000001F6         ;Output Parameter:
  510 000001F6         ; C: APSR bit set to 0, other PSR bits unchanged
  511 000001F6         ;modified registers:
  512 000001F6         ; no registers other than PSR bit C have changed values
  513 000001F6         ; after return
  514 000001F6         ;****************************************************************
  515 000001F6 B503            PUSH             {LR,R0-R1}
  516 000001F8 F3EF 8000       MRS              R0,APSR
  517 000001FC 2120            MOVS             R1,#0x20
  518 000001FE 0609            LSLS             R1,R1,#24
  519 00000200 4388            BICS             R0,R0,R1
  520 00000202 F380 8800       MSR              APSR,R0
  521 00000206 BD03            POP              {PC,R0-R1}
  522 00000208 4770            BX               LR
  523 0000020A                 ENDP
  524 0000020A         
  525 0000020A         JustSetC
                               PROC             {R0-R14}
  526 0000020A         ;****************************************************************
  527 0000020A         ;Description:
  528 0000020A         ; A subroutine with the sole purpose of setting the APSR 
  529 0000020A         ; bit "C" to 1
  530 0000020A         ;Input Parameter:
  531 0000020A         ; none
  532 0000020A         ;Output Parameter:
  533 0000020A         ; C: APSR bit set to 1, other PSR bits unchanged
  534 0000020A         ;modified registers:
  535 0000020A         ; no registers other than PSR bit C have changed values
  536 0000020A         ; after return
  537 0000020A         ;****************************************************************
  538 0000020A B503            PUSH             {LR,R0-R1}
  539 0000020C F3EF 8000       MRS              R0,APSR
  540 00000210 2120            MOVS             R1,#0x20
  541 00000212 0609            LSLS             R1,R1,#24
  542 00000214 4308            ORRS             R0,R0,R1



ARM Macro Assembler    Page 15 Lab Exercise Ten: Timer Driver Input Timing


  543 00000216 F380 8800       MSR              APSR,R0
  544 0000021A BD03            POP              {PC,R0-R1}
  545 0000021C 4770            BX               LR
  546 0000021E                 ENDP
  547 0000021E         
  548 0000021E         Dequeue PROC             {R2-R14}
  549 0000021E         ;****************************************************************
  550 0000021E         ;Description:
  551 0000021E         ; Attempts to get a character from the queue whose record structure’s
  552 0000021E         ; address is in R1: if the queue is not empty, dequeues a single character
  553 0000021E         ; from the queue to R0, and returns with the PSR C bit cleared, (i.e., 0),
  554 0000021E         ; to report dequeue success, otherwise, returns with the PSR C bit set, 
  555 0000021E         ; (i.e., 1), to report dequeue failure.
  556 0000021E         ;Input Parameter: 
  557 0000021E         ; R1: queue record structure (unsigned word address)
  558 0000021E         ;Output Parameter/: 
  559 0000021E         ; R0: character dequeued (unsigned byte ASCII code)
  560 0000021E         ; R1: queue record structure (unsigned word address)
  561 0000021E         ; C: dequeue operation status: 0 success; 1 failure (PSR bit flag)
  562 0000021E         ;modified registers:
  563 0000021E         ; no registers other than PSR (and any output parameters) have changed values
  564 0000021E         ; after return
  565 0000021E         ;subroutines utilized:
  566 0000021E         ; JustClearC
  567 0000021E         ; JustSetC
  568 0000021E         ;****************************************************************
  569 0000021E B51C            PUSH             {LR,R2-R4}
  570 00000220         ;first check if the queue is empty - if so indicate failure + end
  571 00000220 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;R2 <- number of items in queue
  572 00000222 2300            MOVS             R3,#0       ;R3 <- 0
  573 00000224 429A            CMP              R2,R3
  574 00000226 D00F            BEQ              queueEmpty  ;if num_enqued==0,end and fail
  575 00000228         ;otherwise dequeue into r0, update record, and indicate success
  576 00000228 684C            LDR              R4,[R1,#OUT_PTR] ;load OUT_PTR addr into R4
  577 0000022A 7820            LDRB             R0,[R4,#0]  ;load byte value stored in addr in R4
  578 0000022C         ;update records and such
  579 0000022C 1E52            SUBS             R2,R2,#1    ;r2 <- r2-1
  580 0000022E 744A            STRB             R2,[R1,#NUM_ENQD] ;store decremented number s
  581 00000230         ;increment OUT_PTR (loop it to BUF_STRT if it hits BUF_PAST)
  582 00000230 684A            LDR              R2,[R1,#OUT_PTR]
  583 00000232 1C52            ADDS             R2,R2,#1    ;increment OUT_PTR
  584 00000234 68CB            LDR              R3,[R1,#BUF_PAST]



ARM Macro Assembler    Page 16 Lab Exercise Ten: Timer Driver Input Timing


  585 00000236 429A            CMP              R2,R3
  586 00000238 DA01            BGE              passedBuffer ;branch if hit buf_past
  587 0000023A 604A            STR              R2,[R1,#OUT_PTR] ;if no branch, store incremented out ptr
  588 0000023C E001            B                successDequeue ;branch to clear c and end
  589 0000023E         passedBuffer
  590 0000023E 688B            LDR              R3,[R1,#BUF_STRT]
  591 00000240 604B            STR              R3,[R1,#OUT_PTR] ;store new out pointer as start of buf 
  592 00000242         successDequeue                       ;clear c and end subroutine
  593 00000242 F7FF FFFE       BL               JustClearC
  594 00000246 E001            B                endDequeueHere
  595 00000248         queueEmpty
  596 00000248 F7FF FFFE       BL               JustSetC    ;run subroutine to set c and then end
  597 0000024C         endDequeueHere
  598 0000024C BD1C            POP              {PC,R2-R4}
  599 0000024E 4770            BX               LR
  600 00000250                 ENDP
  601 00000250         
  602 00000250         Enqueue PROC             {R2-R14}
  603 00000250         ;****************************************************************
  604 00000250         ;Description:
  605 00000250         ; Attempts to put a character in the queue whose queue record structure’s
  606 00000250         ; address is in R1: if the queue is not full, enqueues the single character 
  607 00000250         ; from R0 to the queue, and returns with the PSR C bit cleared to report 
  608 00000250         ; enqueue success, otherwise, returns with the PSR C bit set to report 
  609 00000250         ; enqueue failure.
  610 00000250         ;Input Parameter: 
  611 00000250         ; R0: character to enqueue (unsigned byte ASCII code)
  612 00000250         ;~~ R1: queue record structure (unsigned word address)
  613 00000250         ;Output Parameter: 
  614 00000250         ; R1: queue record structure (unsigned word address)
  615 00000250         ; C: enqueue operation status: 0 success; 1 failure (PSR bit flag)
  616 00000250         ;modified registers:
  617 00000250         ; no registers other than PSR and any output parameters) have changed values
  618 00000250         ; after return
  619 00000250         ;subroutines utilized:
  620 00000250         ; JustClearC
  621 00000250         ; JustSetC
  622 00000250         ;****************************************************************
  623 00000250 B57C            PUSH             {LR,R2-R6}
  624 00000252 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;R2<-num enqueued (byte)
  625 00000254 7C0B            LDRB             R3,[R1,#BUF_SIZE] ;R3<-max num Q items (byte)
  626 00000256 429A            CMP              R2,R3       ;see if queueFull



ARM Macro Assembler    Page 17 Lab Exercise Ten: Timer Driver Input Timing


  627 00000258 DA11            BGE              queueFull   ;if queueFull go to queueFull
  628 0000025A 680C            LDR              R4,[R1,#IN_PTR] ;R4<-Q IN_PTR
  629 0000025C 7020            STRB             R0,[R4,#0]  ;store char at IN_PTR location 
  630 0000025E 1C52            ADDS             R2,R2,#1    ;increment num_enqued
  631 00000260 744A            STRB             R2,[R1,#NUM_ENQD] ;store updated value
  632 00000262 1C64            ADDS             R4,R4,#1    ;increment IN_PTR past new item
  633 00000264 600C            STR              R4,[R1,#IN_PTR] ;store updated valueof inpointer
  634 00000266 68CD            LDR              R5,[R1,#BUF_PAST] ;R5<-BUF_PAST
  635 00000268 42AC            CMP              R4,R5       ;Compare IN_PTR and BUF_PAST
  636 0000026A D304            BLO              notExceeded ;if IN_PTR less than BUF_PAST: notExceeded
  637 0000026C         ;if queue now full, set inptr to start of queue buffer
  638 0000026C 688E            LDR              R6,[R1,#BUF_STRT] ;R6 <- start Q Buff
  639 0000026E 600E            STR              R6,[R1,#IN_PTR] ;store updated inpointer
  640 00000270 F7FF FFFE       BL               JustClearC  ;indicate successful enqueue
  641 00000274 E005            B                endImmediate
  642 00000276         notExceeded
  643 00000276 600C            STR              R4,[R1,#IN_PTR] ;store updated valueof inpointer
  644 00000278 F7FF FFFE       BL               JustClearC  ;indicate successful enqueue
  645 0000027C E001            B                endImmediate
  646 0000027E         queueFull                            ;set c flag and end
  647 0000027E F7FF FFFE       BL               JustSetC
  648 00000282         endImmediate
  649 00000282 BD7C            POP              {PC,R2-R6}
  650 00000284 4770            BX               LR
  651 00000286                 ENDP
  652 00000286         
  653 00000286         InitQueue
                               PROC             {R0-R14}
  654 00000286         ;****************************************************************
  655 00000286         ;Description:
  656 00000286         ; Initializes the queue record structure at the address in R1 for the empty
  657 00000286         ; queue buffer at the address in R0 of size given in R2, (i.e., character 
  658 00000286         ; capacity).
  659 00000286         ;Input Parameter: 
  660 00000286         ; R0: queue buffer (unsigned word address)
  661 00000286         ; R1: queue record structure (unsigned word address)
  662 00000286         ; R2: queue capacity in bytes (unsigned byte value)
  663 00000286         ;Output Parameter: none
  664 00000286         ;modified registers:
  665 00000286         ; no registers other than PSR and any output parameters) have changed values
  666 00000286         ; after return
  667 00000286         ;****************************************************************



ARM Macro Assembler    Page 18 Lab Exercise Ten: Timer Driver Input Timing


  668 00000286 B407            PUSH             {R0-R2}
  669 00000288 6008            STR              R0,[R1,#IN_PTR] ;store addr in ptr of Q in rec struct  
  670 0000028A 6048            STR              R0,[R1,#OUT_PTR] ;store addr out ptr of Q in rec struct 
  671 0000028C 6088            STR              R0,[R1,#BUF_STRT] ;store addr Q start in rec struct 
  672 0000028E 1880            ADDS             R0,R0,R2    ;R0 = R0 + Q capacity
  673 00000290 60C8            STR              R0,[R1,#BUF_PAST] ;str 1st addr past Q buff end
  674 00000292 740A            STRB             R2,[R1,#BUF_SIZE] ;store Q capacity in rec struct
  675 00000294 2000            MOVS             R0,#0       ;R0 = 0
  676 00000296 7448            STRB             R0,[R1,#NUM_ENQD] ;store that nothing enqueued so far
  677 00000298 BC07            POP              {R0-R2}
  678 0000029A 4770            BX               LR
  679 0000029C                 ENDP
  680 0000029C         
  681 0000029C         PutNumHex
                               PROC             {R0-R14}
  682 0000029C         ;****************************************************************
  683 0000029C         ;Description:
  684 0000029C         ; Prints to the terminal screen the text hexadecimal representation of the
  685 0000029C         ; unsigned word value in R0. (For example, if R0 contains 0x000012FF, then 
  686 0000029C         ; 000012FF should print on the terminal. Note: 12FF would not be acceptable. 
  687 0000029C         ; Do not use division to determine the hexadecimal digit values—use bit masks 
  688 0000029C         ; and shifts.)
  689 0000029C         ;Input Parameter: 
  690 0000029C         ; R0: number to print in hexadecimal (unsigned word value)
  691 0000029C         ;Output Parameter: none
  692 0000029C         ;modified registers:
  693 0000029C         ; no registers other than PSR and any output parameters) have changed values
  694 0000029C         ; after return
  695 0000029C         ;subroutines utilized:
  696 0000029C         ; PutChar
  697 0000029C         ;****************************************************************
  698 0000029C B5FF            PUSH             {LR,R0-R7}
  699 0000029E 0002            MOVS             R2,R0       ;copy unsigned word value to r2
  700 000002A0 2308            MOVS             R3,#8       ;move 8 to r3 as a comparator
  701 000002A2 2400            MOVS             R4,#0       ;move 0 to r4 as a loop counter (i)
  702 000002A4         ;need to put #0xFFFFFFF0 in r6 as clearing mask
  703 000002A4 260F            MOVS             R6,#2_0000000000001111 ;will try just like this
  704 000002A6         
  705 000002A6         
  706 000002A6 2709            MOVS             R7,#9       ;comporator for ascii
  707 000002A8         convertLoopHex
  708 000002A8 2504            MOVS             R5,#4       ;move 4 to R5 as a multiplication const.



ARM Macro Assembler    Page 19 Lab Exercise Ten: Timer Driver Input Timing


  709 000002AA 0010            MOVS             R0,R2       ;restore original hex value
  710 000002AC 4365            MULS             R5,R4,R5    ;R5<-4*1
  711 000002AE 40E8            LSRS             R0,R0,R5    ;shift right 4*i bits(=1 nibble= 1 hex char)
  712 000002B0         ;and pad with zeros on the left
  713 000002B0 4030            ANDS             R0,R0,R6    ;clear all but LSB of R0
  714 000002B2 42B8            CMP              R0,R7       ;compare single hex digit with 
  715 000002B4 DD01            BLE              hexLessThan9 ;if 9 or less just add 0x30
  716 000002B6 2137            MOVS             R1,#0x37    ;if  >9, add 0x32 (idk why not 0x40) 
  717 000002B8 E000            B                nowConvert
  718 000002BA         hexLessThan9
  719 000002BA 2130            MOVS             R1,#0x30    ;ascii conversion mask
  720 000002BC         nowConvert
  721 000002BC 1840            ADDS             R0,R0,R1    ;convert hex character to ascii
  722 000002BE B401            PUSH             {R0}        ;push R0 to print later in reverse order
  723 000002C0 1C64            ADDS             R4,R4,#1    ;increment i
  724 000002C2 42A3            CMP              R3,R4
  725 000002C4 D000            BEQ              endConvertHex ;once counter equal to 8 its done   
  726 000002C6 E7EF            B                convertLoopHex
  727 000002C8         endConvertHex
  728 000002C8         ;pop 8 times from the stack and print using putchar (LIFO)
  729 000002C8 2400            MOVS             R4,#0       ;new loop counter n at 0
  730 000002CA         LIFOPrintLoop
  731 000002CA 42A3            CMP              R3,R4       ;compare n to 8
  732 000002CC D004            BEQ              finishedLIFOPrint ;when equal stop print looping
  733 000002CE BC01            POP              {R0}
  734 000002D0 F7FF FFFE       BL               PutChar
  735 000002D4 1C64            ADDS             R4,R4,#1    ;increment n
  736 000002D6 E7F8            B                LIFOPrintLoop
  737 000002D8         finishedLIFOPrint
  738 000002D8 BDFF            POP              {PC,R0-R7}
  739 000002DA 4770            BX               LR
  740 000002DC                 ENDP
  741 000002DC         
  742 000002DC         PutNumUB
                               PROC             {R0-R14}
  743 000002DC         ;****************************************************************
  744 000002DC         ;Description:
  745 000002DC         ; Prints to the terminal screen the text decimal representation of the
  746 000002DC         ; unsigned byte value in R0. (For example, if R0 contains 0x003021101, 
  747 000002DC         ; then 1 should print on the terminal. Note: 001 would also be acceptable, 
  748 000002DC         ; as the text decimal representation of 0x01.) (Hint: use a mask to preserve 
  749 000002DC         ; only the least byte of the word in R0, and call your PutNumU subroutine



ARM Macro Assembler    Page 20 Lab Exercise Ten: Timer Driver Input Timing


  750 000002DC         ; from Lab Exercise Six.)
  751 000002DC         ;Input Parameter: 
  752 000002DC         ; R0: number to print in decimal (unsigned byte value)
  753 000002DC         ;Output Parameter: none
  754 000002DC         ;modified registers:
  755 000002DC         ; no registers other than PSR and any output parameters) have changed values
  756 000002DC         ; after return
  757 000002DC         ;subroutines utilized:
  758 000002DC         ; PutNumU
  759 000002DC         ;****************************************************************
  760 000002DC B503            PUSH             {LR,R0-R1}
  761 000002DE 210F            MOVS             R1,#2_00001111 ;put mask into r1-1
  762 000002E0 B249            SXTB             R1,R1       ;sign extend to finish
  763 000002E2 4008            ANDS             R0,R0,R1    ;AND with the mask to preserve only LSB
  764 000002E4 F7FF FFFE       BL               PutNumU     ;use PutNumU to print the byte
  765 000002E8 BD03            POP              {PC,R0-R1}
  766 000002EA 4770            BX               LR
  767 000002EC                 ENDP
  768 000002EC         
  769 000002EC         PutNumU PROC             {R0-R14}
  770 000002EC         ;****************************************************************
  771 000002EC         ;Displays text decimal representation of value to terminal screen
  772 000002EC         ;This subroutine displays the text decimal representation to the
  773 000002EC         ;terminal screen of the unsigned word value in R0, using PutChar 
  774 000002EC         ;to output each decimal digit character. (For example, if R0 
  775 000002EC         ;contains 0x00000100, then 256 should be output 0000000256 would 
  776 000002EC         ;also be acceptable.) (hint use divU)
  777 000002EC         ;Input Parameters: 
  778 000002EC         ;R0: number for output to terminal(unsigned word value)
  779 000002EC         ;Output Parameter:
  780 000002EC         ; none
  781 000002EC         ;no registers but PSR changed after return
  782 000002EC         ;Subroutines used:
  783 000002EC         ; DIVU
  784 000002EC         ; PutChar
  785 000002EC         ;****************************************************************
  786 000002EC B53F            PUSH             {LR,R0-R5}
  787 000002EE 0002            MOVS             R2,R0       ;backup word value in R2
  788 000002F0 230A            MOVS             R3,#10      ;store 10 to be the denominator
  789 000002F2 2400            MOVS             R4,#0       ;store counter in R4
  790 000002F4 0011            MOVS             R1,R2       ;move word value to numerator
  791 000002F6         convertLoop



ARM Macro Assembler    Page 21 Lab Exercise Ten: Timer Driver Input Timing


  792 000002F6 0018            MOVS             R0,R3       ;move 10 to be the denominator
  793 000002F8         
  794 000002F8 F7FF FFFE       BL               DIVU        ;use DIVU    
  795 000002FC B402            PUSH             {R1}        ;store the remainder in the stack
  796 000002FE 1C64            ADDS             R4,R4,#1    ;increment counter
  797 00000300 0001            MOVS             R1,R0       ;move the quotient so that it will be the ~~~~
  798 00000302         ;numerator next time around
  799 00000302 2800            CMP              R0,#0       ;check if quotient is 0, if so done
  800 00000304 D1F7            BNE              convertLoop ;if quotient not equal 0 go again
  801 00000306         popLoop
  802 00000306 BC01            POP              {R0}        ;pop individual result to the register r0
  803 00000308 2530            MOVS             R5,#0x30    ;move hex 30 into the register
  804 0000030A 1940            ADDS             R0,R0,R5    ;add to r0 to make ascii from dec
  805 0000030C F7FF FFFE       BL               PutChar     ;use putchar to output to the terminal  
  806 00000310 1E64            SUBS             R4,R4,#1    ;decrement counter
  807 00000312 2C00            CMP              R4,#0       ;see if counter is back to 0
  808 00000314 DCF7            BGT              popLoop     ;if counter still positive loop again  
  809 00000316 BD3F            POP              {PC,R0-R5}  ;restore registers
  810 00000318 4770            BX               LR          ;branch back to where putNumU was called
  811 0000031A                 ENDP
  812 0000031A         
  813 0000031A         DIVU    PROC             {R2-R14}
  814 0000031A         ;****************************************************************
  815 0000031A         ;Subroutine from lab 4 created to perform integer division
  816 0000031A         ;Input: Parameters:
  817 0000031A         ; R0: divisor (denominator)
  818 0000031A         ; R1: dividend (numerator)
  819 0000031A         ;Output Parameters
  820 0000031A         ; R0: quotient
  821 0000031A         ; R1: remainder
  822 0000031A         ; C: APSR flag: 0 for valid result; 1 for invalid result
  823 0000031A         ;****************************************************************
  824 0000031A 2800            CMP              R0,#0       ;check if divisor (denominator) is already zero
  825 0000031C D015            BEQ              div0        ;if so branch to div0 to set c flag
  826 0000031E B40C            PUSH             {R2,R3}     ;store R2 and R3 on the stack
  827 00000320 2900            CMP              R1,#0       ;check if dividend(numerator) is zero
  828 00000322 D007            BEQ              zerodiv     ;if so set outputs to 0 and clear C flag
  829 00000324         
  830 00000324         ;actual division part
  831 00000324 2200            MOVS             R2,#0       ;quotient =0 (R2 will be quotient while computing)
  832 00000326         divuloop
  833 00000326 4281            CMP              R1,R0       ;while dividend>=divisor



ARM Macro Assembler    Page 22 Lab Exercise Ten: Timer Driver Input Timing


  834 00000328 D302            BLO              divuFinish
  835 0000032A 1A09            SUBS             R1,R1,R0    ;dividend=dividend-divisor
  836 0000032C 1C52            ADDS             R2,R2,#1    ;quotient=quotient+1
  837 0000032E E7FA            B                divuloop
  838 00000330         divuFinish
  839 00000330 0010            MOVS             R0,R2       ;R0 =quotient = p
  840 00000332         ;R1 = remainder = dividend = q
  841 00000332 E001            B                clearC      ;branch and clearC then endit
  842 00000334         zerodiv                              ;if dividing zero by anything the result is 0 rem 0
  843 00000334 2000            MOVS             R0,#0
  844 00000336 2100            MOVS             R1,#0
  845 00000338         clearC
  846 00000338 F3EF 8200       MRS              R2,APSR
  847 0000033C 2320            MOVS             R3,#0x20
  848 0000033E 061B            LSLS             R3,R3,#24
  849 00000340 439A            BICS             R2,R2,R3
  850 00000342 F382 8800       MSR              APSR,R2
  851 00000346 BC0C            POP              {R2,R3}     ;restore R2 and R3 from stack
  852 00000348 E001            B                endit
  853 0000034A         div0                                 ;time to set the C flag and leave all else unchanged
  854 0000034A F7FF FFFE       BL               JustSetC
  855 0000034E         endit
  856 0000034E 4770            BX               LR
  857 00000350                 ENDP
  858 00000350         
  859 00000350         PutStringSB
                               PROC             {R0-R14}
  860 00000350         ;****************************************************************
  861 00000350         ;Displays string from memory to terminal screen
  862 00000350         ;Preventing overrun of the buffer capacity specified in R1, 
  863 00000350         ;this subroutine displays a null-terminated string to the terminal 
  864 00000350         ;screen from memory starting at the address in R0. It uses PutChar 
  865 00000350         ;to display characters from the string and leaves the terminal 
  866 00000350         ;screen cursor positioned after the last character of the string.
  867 00000350         ;Input Parameters: 
  868 00000350         ; R0: string buffer in memory for output to simulated output stream 
  869 00000350         ; (unsigned word address)
  870 00000350         ; R1: bytes in string buffer where R0 points (unsigned word value)
  871 00000350         ;Output Parameter:
  872 00000350         ; none
  873 00000350         ;no registers but PSR changed after return
  874 00000350         ;Subroutines used:



ARM Macro Assembler    Page 23 Lab Exercise Ten: Timer Driver Input Timing


  875 00000350         ; PutChar
  876 00000350         ;****************************************************************
  877 00000350         
  878 00000350 B50F            PUSH             {LR,R0-R3}
  879 00000352 0002            MOVS             R2,R0       ;copy starting address of string
  880 00000354 2300            MOVS             R3,#0       ;initialize counter
  881 00000356         printLoop
  882 00000356 5CD0            LDRB             R0,[R2,R3]  ;configure input to PutChar correctly with
  883 00000358         ;offset
  884 00000358 2800            CMP              R0,#NULL    ;compare to see if null character an
  885 0000035A D004            BEQ              stopPrint   ;if so terminate
  886 0000035C         
  887 0000035C F7FF FFFE       BL               PutChar     ;use putchar to output char R0 to terminal   
  888 00000360         
  889 00000360 1C5B            ADDS             R3,R3,#1    ;increment counter
  890 00000362 428B            CMP              R3,R1
  891 00000364 DDF7            BLE              printLoop   ;if the counter is less than or equal to the 
  892 00000366         stopPrint                            ;num bytes in the string branch and get next
  893 00000366 BD0F            POP              {PC,R0-R3}  ;otherwise restore registers and exit
  894 00000368 4770            BX               LR
  895 0000036A                 ENDP
  896 0000036A         
  897 0000036A         GetStringSB
                               PROC             {R1-R14}
  898 0000036A         ;****************************************************************
  899 0000036A         ;Inputs string from terminal reventing overrun 
  900 0000036A         ;Preventing overrun of the buffer capacity specified in R1, this
  901 0000036A         ;subroutine inputs a string from the terminal keyboard to memory 
  902 0000036A         ;starting at the address in R0 and adds null termination. It ends 
  903 0000036A         ;terminal keyboard input when the user presses the enter key. 
  904 0000036A         ;For each of up to R1 - 1 characters typed on the terminal 
  905 0000036A         ;keyboard, it uses GetChar to input the character, uses PutChar 
  906 0000036A         ;to echo the character to the terminal screen, and stores the 
  907 0000036A         ;character at the next position in the string. For any character
  908 0000036A         ;typed after the first R1 - 1 characters, it uses GetChar to input 
  909 0000036A         ;the character, but it neither stores the character in the string 
  910 0000036A         ;nor echoes the character to the terminal screen.When the carriage 
  911 0000036A         ;return character has been received, it null terminates the string,
  912 0000036A         ;advances the cursor on the terminal screen to the beginning of 
  913 0000036A         ;the next line, and returns.
  914 0000036A         ;Input Parameter: 
  915 0000036A         ;~~~R0: should be mem adress to start at. Not specified in doc



ARM Macro Assembler    Page 24 Lab Exercise Ten: Timer Driver Input Timing


  916 0000036A         ; R1: bytes in string buffer where R0 points(unsigned word value)
  917 0000036A         ;Output Parameter: 
  918 0000036A         ; R0: string buffer in memory for input from user (unsigned word 
  919 0000036A         ;  address)
  920 0000036A         ;no registers but PSR changed after return
  921 0000036A         ;Subroutines used:
  922 0000036A         ; GetChar
  923 0000036A         ; PutChar
  924 0000036A         ;****************************************************************
  925 0000036A B53F            PUSH             {LR,R0-R5}
  926 0000036C 0003            MOVS             R3,R0       ;copy address to store in to R3
  927 0000036E 1E4C            SUBS             R4,R1,#1    ;store R1-1 in R4
  928 00000370 2200            MOVS             R2,#0       ;initialize r2 as 0 for num chars typed
  929 00000372         loopHere
  930 00000372 F7FF FFFE       BL               GetChar     ;Get char from terminal (now in R0)
  931 00000376 0015            MOVS             R5,R2       ;r5 1 less then r2 for storage purposes
  932 00000378 1C52            ADDS             R2,R2,#1    ;increment r2
  933 0000037A         
  934 0000037A 280D            CMP              R0,#CR      ;compare the character typed to carriage return
  935 0000037C D005            BEQ              enterPressed ;if equal branch accordingly
  936 0000037E         
  937 0000037E 42A2            CMP              R2,R4       ;compare r1-1 with num chars typed so far
  938 00000380 DCF7            BGT              loopHere    ;if r2 > r4 then no output or store
  939 00000382         
  940 00000382         ;output and store 
  941 00000382 F7FF FFFE       BL               PutChar     ;output char in r0 to terminal
  942 00000386 5558            STRB             R0,[R3,R5]  ;store in addr r0 inc offset
  943 00000388 E7F3            B                loopHere
  944 0000038A         
  945 0000038A         enterPressed
  946 0000038A         ;LDR  R0,=lenOpStr;load address to store the length of op str in
  947 0000038A 42A5            CMP              R5,R4       ;if length greater than max length
  948 0000038C DD00            BLE              notExceed
  949 0000038E 0025            MOVS             R5,R4       ;store length as max length
  950 00000390         notExceed
  951 00000390         ;STRB R5,[R0,#0] ;store the length of the op str 
  952 00000390 2000            MOVS             R0,#NULL    ;move equate null into r0 
  953 00000392 5558            STRB             R0,[R3,R5]  ;store null in addr r0 inc offset   
  954 00000394 BD3F            POP              {PC,R0-R5}
  955 00000396 4770            BX               LR
  956 00000398                 ENDP
  957 00000398         ;>>>>>   end subroutine code <<<<<



ARM Macro Assembler    Page 25 Lab Exercise Ten: Timer Driver Input Timing


  958 00000398                 ALIGN
  959 00000398         ;****************************************************************
  960 00000398         ;Vector Table Mapped to Address 0 at Reset
  961 00000398         ;Linker requires __Vectors to be exported
  962 00000398 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40037100 
              4004803C 
              00800000 
              00000001 
              E000E414 
              00C00000 
              E000E280 
              00400000 
              E000E100 
              40037000 
              0003A8F5 
              4006A000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 
              40048034 
              00000400 
              40048038 
              4004A008 
              01000200 



ARM Macro Assembler    Page 26 Lab Exercise Ten: Timer Driver Input Timing


              4004A004 
              E000E40C 
              000000C0 
              00001000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000         AREA             RESET, DATA, READONLY
  963 00000000                 EXPORT           __Vectors
  964 00000000                 EXPORT           __Vectors_End
  965 00000000                 EXPORT           __Vectors_Size
  966 00000000                 IMPORT           __initial_sp
  967 00000000                 IMPORT           Dummy_Handler
  968 00000000                 IMPORT           HardFault_Handler
  969 00000000         __Vectors
  970 00000000         ;ARM core vectors
  971 00000000 00000000        DCD              __initial_sp ;00:end of stack
  972 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  973 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  974 0000000C 00000000        DCD              HardFault_Handler ;03:hard fault
  975 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  976 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  977 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  978 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  979 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  980 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  981 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  982 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
  983 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  984 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  985 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (PendableSrvReq)
  986 0000003C         ;   pendable request 
  987 0000003C         ;   for system service)
  988 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
  989 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 transfer 
  990 00000044         ;   complete/error
  991 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 transfer
  992 00000048         ;   complete/error
  993 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 transfer
  994 0000004C         ;   complete/error



ARM Macro Assembler    Page 27 Lab Exercise Ten: Timer Driver Input Timing


  995 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 transfer
  996 00000050         ;   complete/error
  997 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  998 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command complete/
  999 00000058         ;   read collision
 1000 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
 1001 0000005C         ;   low-voltage warning
 1002 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
 1003 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1004 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
 1005 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
 1006 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
 1007 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; error)
 1008 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
 1009 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
 1010 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1011 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1012 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1013 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1014 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
 1015 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1016 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
 1017 00000098 00000000        DCD              PIT_ISR     ;38:PIT
 1018 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
 1019 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)
 1020 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1021 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1022 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1023 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1024 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
 1025 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
 1026 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
 1027 000000C0         __Vectors_End
 1028 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1029 000000C0                 ALIGN
 1030 000000C0         ;****************************************************************
 1031 000000C0         ;Constants
 1032 000000C0                 AREA             MyConst,DATA,READONLY
 1033 00000000         ;>>>>> begin constants here <<<<<
 1034 00000000 45 6E 74 



ARM Macro Assembler    Page 28 Lab Exercise Ten: Timer Driver Input Timing


              65 72 20 
              79 6F 75 
              72 20 6E 
              61 6D 65 
              2E       Name_Prompt
                               DCB              "Enter your name."
 1035 00000010 20 78 20 
              30 2E 30 
              31 20 73 Count_Suffix
                               DCB              " x 0.01 s"
 1036 00000019 45 6E 74 
              65 72 20 
              74 68 65 
              20 44 61 
              74 65    Date_Prompt
                               DCB              "Enter the Date"
 1037 00000027 45 6E 74 
              65 72 20 
              74 68 65 
              20 6C 61 
              73 74 20 
              6E 61 6D 
              65 20 6F 
              66 20 61 
              20 32 35 
              30 20 6C 
              61 62 20 
              54 41 2E TA_Prompt
                               DCB              "Enter the last name of a 250 lab TA."
 1038 0000004B 54 68 61 
              6E 6B 20 
              79 6F 75 
              2E 20 20 
              47 6F 6F 
              64 62 79 
              65 21    EndMessage
                               DCB              "Thank you.  Goodbye!"
 1039 0000005F         ;>>>>>   end constants here <<<<<
 1040 0000005F 00              ALIGN
 1041 00000060         ;****************************************************************
 1042 00000060         ;Variables
 1043 00000060                 AREA             MyData,DATA,READWRITE



ARM Macro Assembler    Page 29 Lab Exercise Ten: Timer Driver Input Timing


 1044 00000000         ;>>>>> begin variables here <<<<<
 1045 00000000 00 00 00 
              00       Count   SPACE            4           ;word
 1046 00000004 00      RunStopWatch
                               SPACE            1           ;byte variable (boolean)
 1047 00000005 00 00 00        ALIGN
 1048 00000008 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQRecord
                               SPACE            18          ;record structure for TxQBuffer
 1049 0000001A 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    TxQBuffer
                               SPACE            80          ;80 character transmit queue buffer
 1050 0000006A 00 00           ALIGN



ARM Macro Assembler    Page 30 Lab Exercise Ten: Timer Driver Input Timing


 1051 0000006C 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQRecord
                               SPACE            18          ;record structure for RxQBuffer
 1052 0000007E 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxQBuffer
                               SPACE            80          ;80 character recieve queue buffer
 1053 000000CE 00 00           ALIGN
 1054 000000D0         ;following from Lab 7
 1055 000000D0 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 31 Lab Exercise Ten: Timer Driver Input Timing


              00 00 00 QRecord SPACE            18          ;allocate 18 bytes to variable QRecord
 1056 000000E2 00 00 00 
              00       QBuffer SPACE            4           ;allocate 4  bytes to variable QBuffer
 1057 000000E6 00 00           ALIGN
 1058 000000E8 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    StringMem
                               SPACE            80
 1059 00000138         ;>>>>>   end variables here <<<<<
 1060 00000138                 ALIGN
 1061 00000138                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\objects\
exercise10.d -o.\objects\exercise10.o -IC:\Users\Atticus\AppData\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Inc
lude -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSION SETA 531" --predefine="MK
L05Z32xxx4 SETA 1" --list=.\listings\exercise10.lst Exercise10.s
